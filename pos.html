<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Luma Store OS ‚Äî POS</title>

  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet"/>

  <style>
    :root{
      --bg:#f3f4f6;
      --panel:#ffffff;
      --panel-soft:#f9fafb;
      --ink:#111827;
      --muted:#6b7280;
      --border:#e5e7eb;
      --accent:#2563eb;
      --accent-soft:#dbeafe;
      --accent-strong:#1d4ed8;
      --radius:16px;
      --shadow:0 18px 40px rgba(15,23,42,.12);
      --danger:#ef4444;
      --ok:#16a34a;
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{
      height:100%;
      font-family:"Montserrat",system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background:var(--bg);
      color:var(--ink);
    }
    body{
      min-height:100vh;
      padding:14px;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .hidden{display:none !important;}

    /* LOGIN */
    .auth-wrapper{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:20px;
      background:radial-gradient(circle at top,#e5edff,#f3f4f6 46%,#e5e7eb 100%);
      z-index:30;
    }
    .auth-shell{
      width:100%;
      max-width:380px;
      background:var(--panel);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      border:1px solid rgba(148,163,184,.3);
      padding:18px 18px 16px;
    }
    .auth-header{
      display:flex;
      align-items:center;
      gap:10px;
      margin-bottom:10px;
    }
    .auth-logo{
      width:34px;height:34px;border-radius:999px;
      background:linear-gradient(135deg,#2563eb,#a855f7);
      display:flex;align-items:center;justify-content:center;
      color:#fff;font-weight:700;font-size:18px;
    }
    .auth-title{
      font-size:16px;font-weight:700;
    }
    .auth-subtitle{
      font-size:11px;color:var(--muted);margin-top:2px;
    }
    .auth-alert{
      font-size:11px;
      padding:6px 9px;
      border-radius:9px;
      margin-bottom:8px;
    }
    .auth-alert-error{
      background:#fef2f2;
      color:#b91c1c;
      border:1px solid #fecaca;
    }
    .field{
      margin-bottom:8px;
    }
    .field-label{
      font-size:11px;margin-bottom:3px;color:#4b5563;
    }
    .field-input{
      width:100%;
      padding:8px 9px;
      border-radius:9px;
      border:1px solid var(--border);
      background:#f9fafb;
      font-size:12px;
    }
    .field-input:focus{
      outline:none;
      border-color:var(--accent);
      box-shadow:0 0 0 1px var(--accent-soft);
    }
    .btn-auth{
      width:100%;
      border:none;
      border-radius:999px;
      padding:9px 12px;
      font-size:13px;
      font-weight:600;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      background:var(--accent);
      color:#fff;
      box-shadow:0 12px 28px rgba(37,99,235,.3);
    }
    .btn-auth:hover{
      background:var(--accent-strong);
    }
    .btn-auth:disabled{
      opacity:.7;cursor:default;box-shadow:none;
    }
    .auth-footer{
      text-align:center;
      margin-top:8px;
      font-size:10px;
      color:var(--muted);
    }

    /* POS SHELL */
    .shell{
      width:100%;
      max-width:1180px;
      background:var(--panel);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      border:1px solid var(--border);
      padding:12px 14px 14px;
      display:none;
      flex-direction:column;
      gap:10px;
    }
    .topbar{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:10px;
      border-bottom:1px solid var(--border);
      padding-bottom:6px;
    }
    .top-left{
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .title{
      font-size:18px;font-weight:700;
    }
    .subtitle{
      font-size:11px;color:var(--muted);
    }
    .brand-chip{
      display:flex;
      align-items:center;
      gap:8px;
      font-size:11px;
      margin-top:4px;
    }
    .brand-logo{
      width:26px;height:26px;border-radius:999px;
      background:linear-gradient(135deg,#2563eb,#a855f7);
      display:flex;align-items:center;justify-content:center;
      color:#fff;font-weight:700;font-size:14px;
      overflow:hidden;
      flex-shrink:0;
    }
    .brand-logo img{
      width:100%;
      height:100%;
      object-fit:cover;
      border-radius:999px;
      display:block;
    }

    .top-right{
      display:flex;
      flex-direction:column;
      gap:6px;
      align-items:flex-end;
    }
    .top-actions{
      display:flex;
      align-items:center;
      gap:8px;
    }
    .top-search-wrap{
      position:relative;
    }
    .top-search-input{
      width:210px;
      max-width:50vw;
      padding:7px 9px;
      border-radius:999px;
      border:1px solid var(--border);
      background:#fff;
      font-size:12px;
    }
    .top-search-input:focus{
      outline:none;
      border-color:var(--accent);
      box-shadow:0 0 0 1px var(--accent-soft);
    }
    .cart-pill{
      display:flex;
      align-items:center;
      gap:6px;
      padding:5px 9px;
      border-radius:999px;
      border:1px solid var(--border);
      background:var(--panel-soft);
      font-size:11px;
    }
    .cart-pill-count{
      font-weight:600;
    }
    .cart-pill-total{
      color:var(--muted);
      font-size:11px;
    }

    .mode-toggle{
      display:flex;
      align-items:center;
      gap:4px;
      margin-top:2px;
      justify-content:flex-end;
    }
    .mode-label{
      font-size:10px;
      color:var(--muted);
    }
    .mode-group{
      display:inline-flex;
      border-radius:999px;
      border:1px solid var(--border);
      background:#f9fafb;
      overflow:hidden;
    }
    .mode-pill{
      font-size:10px;
      padding:4px 10px;
      border:none;
      background:transparent;
      cursor:pointer;
      color:#6b7280;
    }
    .mode-pill-active{
      background:#2563eb;
      color:#fff;
    }

    .user-chip{
      display:flex;
      align-items:center;
      gap:7px;
      border-radius:999px;
      border:1px solid var(--border);
      padding:6px 9px;
      background:var(--panel-soft);
      font-size:11px;
    }
    .user-initials{
      width:24px;height:24px;border-radius:999px;
      background:var(--accent-soft);
      display:flex;align-items:center;justify-content:center;
      font-size:11px;font-weight:600;color:var(--accent-strong);
    }
    .user-text{
      display:flex;flex-direction:column;
    }
    .user-name{
      font-size:11px;font-weight:600;
    }
    .user-role{
      font-size:10px;color:var(--muted);
    }

    .main-row{
      display:grid;
      grid-template-columns:1.3fr 1fr; /* LEFT: products/returns, RIGHT: cart */
      gap:10px;
      margin-top:6px;
    }
    @media(max-width:900px){
      body{padding:8px;}
      .shell{padding:10px;}
      .topbar{flex-direction:column;align-items:flex-start;}
      .top-right{align-items:flex-start;}
      .main-row{grid-template-columns:1fr;}
    }
    .card{
      background:var(--panel-soft);
      border-radius:12px;
      border:1px solid var(--border);
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .card-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:6px;
    }
    .card-title{
      font-size:13px;font-weight:600;
    }
    .card-subtitle{
      font-size:11px;color:var(--muted);
    }
    .badge{
      font-size:10px;
      padding:2px 6px;
      border-radius:999px;
      background:#eef2ff;
      color:#4f46e5;
    }

    .alert{
      font-size:11px;
      padding:6px 9px;
      border-radius:9px;
      margin-bottom:4px;
    }
    .alert-info{
      background:#eff6ff;
      color:#1d4ed8;
      border:1px solid #bfdbfe;
    }
    .alert-error{
      background:#fef2f2;
      color:#b91c1c;
      border:1px solid #fecaca;
    }
    .alert-ok{
      background:#ecfdf5;
      color:#15803d;
      border:1px solid #bbf7d0;
    }

    .field-row{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
    }
    .field-pos{
      flex:1;
      min-width:120px;
    }
    .field-label-pos{
      font-size:11px;margin-bottom:3px;color:#4b5563;
    }
    .field-input-pos, .field-select-pos{
      width:100%;
      padding:7px 9px;
      border-radius:9px;
      border:1px solid var(--border);
      background:#fff;
      font-size:12px;
    }
    .field-input-pos:focus, .field-select-pos:focus{
      outline:none;
      border-color:var(--accent);
      box-shadow:0 0 0 1px var(--accent-soft);
    }
    .field-hint-pos{
      font-size:10px;color:var(--muted);margin-top:2px;
    }

    .btn{
      border:none;
      border-radius:999px;
      padding:7px 12px;
      font-size:12px;
      font-weight:600;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:6px;
      white-space:nowrap;
    }
    .btn-primary{
      background:var(--accent);
      color:#fff;
      box-shadow:0 10px 24px rgba(37,99,235,.25);
    }
    .btn-primary:hover{
      background:var(--accent-strong);
    }
    .btn-ghost{
      background:transparent;
      color:var(--accent-strong);
      border:1px solid var(--accent-soft);
    }
    .btn-ghost:hover{
      background:var(--accent-soft);
    }
    .btn-small{
      padding:5px 9px;
      font-size:11px;
    }
    .btn-danger{
      background:#fee2e2;
      color:#b91c1c;
      border:1px solid #fecaca;
    }

    .cart-table-wrapper{
      border-radius:10px;
      border:1px solid var(--border);
      overflow:hidden;
      background:#fff;
    }
    table{
      width:100%;
      border-collapse:collapse;
      font-size:12px;
    }
    th,td{
      padding:7px 8px;
      text-align:left;
      border-bottom:1px solid var(--border);
      vertical-align:middle;
    }
    thead{
      background:#f3f4f6;
    }
    th{
      font-size:10px;
      text-transform:uppercase;
      letter-spacing:.08em;
      color:var(--muted);
    }
    tbody tr:hover{
      background:#f9fafb;
    }
    .empty{
      text-align:center;
      font-size:11px;
      color:var(--muted);
      padding:12px 4px;
    }

    .qty-control{
      display:inline-flex;
      align-items:center;
      gap:3px;
      border-radius:999px;
      border:1px solid var(--border);
      padding:1px 4px;
      background:#fff;
    }
    .qty-btn{
      border:none;
      background:transparent;
      font-size:11px;
      cursor:pointer;
      width:16px;
      text-align:center;
    }
    .qty-val{
      min-width:18px;
      text-align:center;
      font-size:11px;
    }

    .summary{
      display:flex;
      flex-direction:column;
      gap:4px;
      font-size:12px;
      margin-top:4px;
    }
    .summary-row{
      display:flex;
      justify-content:space-between;
      align-items:center;
    }
    .summary-label{
      color:var(--muted);
    }
    .summary-total{
      font-size:15px;
      font-weight:700;
    }

    .products-list{
      border-radius:10px;
      border:1px solid var(--border);
      background:#fff;
      padding:6px;
      max-height:420px;
      overflow:auto;
    }
    .product-item{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:6px 6px;
      border-radius:8px;
      font-size:12px;
      gap:8px;
    }
    .product-item.disabled{
      opacity:.6;
      cursor:not-allowed;
    }
    .product-item:hover{
      background:#e5e7eb;
    }
    .product-main{
      display:flex;
      align-items:center;
      gap:8px;
    }
    .product-thumb{
      width:32px;
      height:32px;
      border-radius:8px;
      background:#e5e7eb;
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:10px;
      color:#6b7280;
      flex-shrink:0;
    }
    .product-thumb img{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
    }
    .product-title{
      font-weight:500;
    }
    .product-meta{
      font-size:10px;
      color:#6b7280;
    }
    .product-right{
      display:flex;
      align-items:center;
      gap:6px;
    }

    /* MODALS (checkout + product) */
    .modal-backdrop{
      position:fixed;
      inset:0;
      background:rgba(15,23,42,.4);
      display:none;
      align-items:center;
      justify-content:center;
      padding:12px;
      z-index:40;
    }
    .modal-panel{
      width:100%;
      max-width:420px;
      background:var(--panel);
      border-radius:16px;
      box-shadow:var(--shadow);
      border:1px solid var(--border);
      padding:14px 16px 12px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .modal-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
    }
    .modal-title{
      font-size:14px;
      font-weight:600;
    }
    .modal-subtitle{
      font-size:11px;
      color:var(--muted);
    }
    .modal-alert{
      font-size:11px;
      padding:6px 9px;
      border-radius:9px;
      margin-top:4px;
    }
    .modal-alert-error{
      background:#fef2f2;
      color:#b91c1c;
      border:1px solid #fecaca;
    }
    .modal-footer{
      display:flex;
      justify-content:flex-end;
      gap:6px;
      margin-top:4px;
    }
    .customer-suggestions{
      margin-top:4px;
      border-radius:9px;
      border:1px solid var(--border);
      background:#f9fafb;
      max-height:120px;
      overflow:auto;
      font-size:11px;
    }
    .customer-suggestion-item{
      padding:6px 8px;
      cursor:pointer;
      border-bottom:1px solid var(--border);
    }
    .customer-suggestion-item:last-child{
      border-bottom:none;
    }
    .customer-suggestion-item:hover{
      background:#e5e7eb;
    }
    .text-muted{
      color:var(--muted);
    }
    .text-note{
      font-size:10px;
      color:var(--muted);
      margin-top:3px;
    }

    /* Product modal body */
    .product-modal-body{
      display:flex;
      gap:10px;
      margin-top:6px;
      align-items:flex-start;
    }
    .product-modal-image{
      width:72px;
      height:72px;
      border-radius:12px;
      background:#e5e7eb;
      overflow:hidden;
      flex-shrink:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:11px;
      color:#6b7280;
    }
    .product-modal-image img{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
    }
    .product-modal-details{
      flex:1;
      display:flex;
      flex-direction:column;
      gap:4px;
      font-size:11px;
      color:var(--muted);
    }
    .product-modal-name{
      font-size:13px;
      font-weight:600;
      color:var(--ink);
    }
    .product-modal-price{
      font-size:12px;
      font-weight:600;
      color:var(--ink);
    }
    .product-modal-stock{
      font-size:11px;
      color:var(--muted);
    }
  </style>
</head>
<body>

  <!-- LOGIN OVERLAY -->
  <div id="pos-auth-wrapper" class="auth-wrapper">
    <div class="auth-shell">
      <div class="auth-header">
        <div class="auth-logo">P</div>
        <div>
          <div class="auth-title">Luma Store OS ‚Äî POS</div>
          <div class="auth-subtitle">
            Log in with a POS user (username + PIN) created from the Brand Dashboard.
          </div>
        </div>
      </div>

      <div id="auth-alert"></div>

      <form id="pos-login-form">
        <div class="field">
          <div class="field-label">Username</div>
          <input id="pos-login-username" class="field-input" placeholder="POS username"/>
        </div>
        <div class="field">
          <div class="field-label">PIN</div>
          <input id="pos-login-pin" class="field-input" type="password" placeholder="PIN (e.g. 4‚Äì6 digits)"/>
        </div>
        <button type="submit" id="pos-login-btn" class="btn-auth">Log in</button>
      </form>

      <div class="auth-footer">
        Admin: in the Brand Dashboard, create a POS user in <code>posUsers</code> with username, pin, brandId and branchId.
      </div>
    </div>
  </div>

  <!-- POS SHELL -->
  <div class="shell" id="pos-shell">
    <header class="topbar">
      <div class="top-left">
        <div class="title">POS</div>
        <div id="subtitle" class="subtitle">Loading brand and branch‚Ä¶</div>
        <div class="brand-chip">
          <div id="brand-logo" class="brand-logo">B</div>
          <div id="brand-chip-text">‚Äî</div>
        </div>
      </div>

      <div class="top-right">
        <div class="top-actions">
          <div class="top-search-wrap">
            <input id="top-product-search" class="top-search-input" placeholder="Search products (name/code)"/>
          </div>
          <div class="cart-pill">
            <span id="cart-summary-count" class="cart-pill-count">0 items</span>
            <span id="cart-summary-total" class="cart-pill-total">0.00</span>
          </div>
          <button type="button" id="btn-open-checkout" class="btn btn-primary btn-small">
            Proceed
          </button>
        </div>
        <div class="mode-toggle">
          <span class="mode-label">Mode:</span>
          <div class="mode-group">
            <button type="button" id="mode-sale" class="mode-pill mode-pill-active">Sale</button>
            <button type="button" id="mode-return" class="mode-pill">Return</button>
          </div>
        </div>
        <div class="user-chip">
          <div id="user-initials" class="user-initials">U</div>
          <div class="user-text">
            <div id="user-name" class="user-name">User</div>
            <div id="user-role" class="user-role">Cashier</div>
          </div>
        </div>
      </div>
    </header>

    <div id="global-alert"></div>

    <div class="main-row">
      <!-- LEFT: PRODUCTS (sale) / ORDER SEARCH (return) -->
      <div class="card">
        <div class="card-header">
          <div>
            <div class="card-title" id="left-card-title">Products</div>
            <div class="card-subtitle" id="left-card-subtitle">
              Scan barcode, type a code, or tap ‚ÄúAdd‚Äù to send items to cart.
            </div>
          </div>
          <span id="branch-badge" class="badge">Branch: ‚Äî</span>
        </div>

        <!-- Code input -->
        <div class="field-row" style="margin-top:4px;">
          <div class="field-pos">
            <div class="field-label-pos" id="code-input-label">Scan or type product code</div>
            <input id="code-input" class="field-input-pos" placeholder="Focus here, then scan or type code"/>
            <div class="field-hint-pos" id="code-input-hint">
              Works with barcode scanners that behave like a keyboard and send Enter after scanning.
            </div>
          </div>
          <div>
            <div class="field-label-pos">&nbsp;</div>
            <button type="button" id="btn-add-code" class="btn btn-primary btn-small">Add to cart</button>
          </div>
        </div>

        <!-- Product list (hidden in return mode) -->
        <div id="products-list" class="products-list">
          <div class="empty">Loading products‚Ä¶</div>
        </div>
      </div>

      <!-- RIGHT: CART + OFFLINE QUEUE -->
      <div class="card">
        <div class="card-header">
          <div>
            <div class="card-title" id="cart-card-title">Cart</div>
            <div class="card-subtitle" id="cart-card-subtitle">
              Adjust quantities or remove items. Proceed to add customer & payment details.
            </div>
          </div>
        </div>

        <!-- Cart table -->
        <div class="cart-table-wrapper">
          <table>
            <thead>
              <tr>
                <th>Item</th>
                <th>Code</th>
                <th>Qty</th>
                <th>Price</th>
                <th>Total</th>
                <th></th>
              </tr>
            </thead>
            <tbody id="cart-tbody">
              <tr><td colspan="6" class="empty">No items yet. Scan or select a product.</td></tr>
            </tbody>
          </table>
        </div>

        <!-- Summary -->
        <div class="summary">
          <div class="summary-row">
            <span class="summary-label" id="summary-subtotal-label">Subtotal</span>
            <span id="summary-subtotal">0.00</span>
          </div>
          <div class="summary-row">
            <span class="summary-label" id="summary-tax-label">VAT (0%)</span>
            <span id="summary-tax">0.00</span>
          </div>
          <div class="summary-row">
            <span class="summary-label" id="summary-service-label">Service Fee (0%)</span>
            <span id="summary-service">0.00</span>
          </div>

          <!-- Discount code input -->
          <div class="summary-row">
            <span class="summary-label">Discount code</span>
            <div style="display:flex; gap:6px; align-items:center;">
              <input id="discount-code-input" class="field-input-pos" style="max-width:130px;" placeholder="Code"/>
              <button type="button" id="btn-apply-discount" class="btn btn-ghost btn-small">Apply</button>
            </div>
          </div>

          <!-- Discount row -->
          <div class="summary-row" id="discount-row" style="display:none;">
            <span class="summary-label" id="discount-label">Discount</span>
            <span id="summary-discount">-0.00</span>
          </div>

          <div class="summary-row">
            <span class="summary-label" id="summary-total-label">Total</span>
            <span id="summary-total" class="summary-total">0.00</span>
          </div>
          <div class="summary-row">
            <span class="summary-label" id="summary-payment-label">Payment method</span>
            <select id="payment-method" class="field-select-pos" style="max-width:180px;">
              <option value="cash">Cash</option>
              <option value="card">Card</option>
              <option value="wallet">Wallet</option>
              <option value="other">Other</option>
            </select>
          </div>
        </div>

        <div class="summary-row" style="margin-top:6px;">
          <button type="button" id="btn-clear-cart" class="btn btn-ghost btn-small">Clear cart</button>
          <button type="button" id="btn-open-checkout-secondary" class="btn btn-primary btn-small">Proceed</button>
        </div>

        <!-- Return full order action (only in return mode) -->
        <div class="summary-row" id="return-full-row" style="margin-top:4px; display:none;">
          <button type="button" id="btn-return-full" class="btn btn-ghost btn-small">Return full order</button>
        </div>

        <div class="text-note" id="return-note" style="display:none;">
          Return mode: load an order by ID or phone, set the quantity to return, then refund. Amounts in the system are stored as negative.
        </div>

        <!-- Offline status + queue -->
        <div id="offline-status" class="alert alert-error" style="display:none;margin-top:6px;"></div>
        <div id="offline-queue-list" class="field-hint-pos" style="margin-top:2px;"></div>
      </div>
    </div>
  </div>

  <!-- PRODUCT DETAIL / VARIANT MODAL -->
  <div id="product-modal" class="modal-backdrop">
    <div class="modal-panel">
      <div class="modal-header">
        <div>
          <div class="modal-title" id="product-modal-title">Add item</div>
          <div class="modal-subtitle" id="product-modal-subtitle">Choose variants (if any) and quantity.</div>
        </div>
        <div class="product-modal-price" id="product-modal-price">0.00</div>
      </div>

      <div class="product-modal-body">
        <div class="product-modal-image" id="product-modal-image">
          No image
        </div>
        <div class="product-modal-details">
          <div class="product-modal-name" id="product-modal-name">Item</div>
          <div id="product-modal-code"></div>
          <div class="product-modal-stock" id="product-modal-stock"></div>
        </div>
      </div>

      <div class="field-row" id="product-modal-variants-row" style="margin-top:6px;">
        <div id="product-modal-variants" class="field-row" style="width:100%;"></div>
      </div>

      <div class="field-row" style="margin-top:4px;">
        <div class="field-pos" style="max-width:150px;">
          <div class="field-label-pos">Quantity</div>
          <input id="product-modal-qty" class="field-input-pos" type="number" min="1" value="1"/>
        </div>
      </div>

      <div class="modal-footer">
        <button type="button" id="btn-product-modal-cancel" class="btn btn-ghost btn-small">Cancel</button>
        <button type="button" id="btn-product-modal-add" class="btn btn-primary btn-small">Add to cart</button>
      </div>
    </div>
  </div>

  <!-- CHECKOUT MODAL -->
  <div id="checkout-modal" class="modal-backdrop">
    <div class="modal-panel">
      <div class="modal-header">
        <div>
          <div class="modal-title" id="checkout-title">Checkout ‚Äî customer & payment</div>
          <div class="modal-subtitle" id="checkout-subtitle">
            Name and email are required. Suggestions appear as you type.
          </div>
          <div class="text-note" id="checkout-original-order-note" style="display:none;"></div>
        </div>
        <span id="checkout-total" class="summary-total">0.00</span>
      </div>

      <div id="checkout-alert" class="modal-alert hidden"></div>

      <div class="field-row">
        <div class="field-pos">
          <div class="field-label-pos">Customer name <span class="text-muted">*</span></div>
          <input id="checkout-customer-name" class="field-input-pos" placeholder="Customer full name"/>
        </div>
      </div>
      <div class="field-row">
        <div class="field-pos">
          <div class="field-label-pos">Phone</div>
          <input id="checkout-customer-phone" class="field-input-pos" placeholder="Optional, used to find customer"/>
        </div>
        <div class="field-pos">
          <div class="field-label-pos">Email <span class="text-muted">*</span></div>
          <input id="checkout-customer-email" class="field-input-pos" type="email" placeholder="Required"/>
        </div>
      </div>

      <div id="checkout-customer-suggestions" class="customer-suggestions hidden"></div>

      <div class="field-row">
        <div class="field-pos">
          <div class="field-label-pos">Payment method</div>
          <div class="field-input-pos" style="background:#f9fafb;" id="checkout-payment-summary">
            <!-- filled from main select -->
          </div>
          <div class="field-hint-pos">
            Change payment method from the main POS screen if needed.
          </div>
        </div>
      </div>

      <div class="field-row" id="card-txn-row" style="display:none;">
        <div class="field-pos">
          <div class="field-label-pos">Card transaction number <span class="text-muted">*</span></div>
          <input id="checkout-card-txn" class="field-input-pos" placeholder="Last 4 / transaction reference"/>
        </div>
      </div>

      <div class="modal-footer">
        <button type="button" id="btn-checkout-cancel" class="btn btn-ghost btn-small">Cancel</button>
        <button type="button" id="btn-checkout-confirm" class="btn btn-primary btn-small">Confirm &amp; place order</button>
      </div>
    </div>
  </div>

  <script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
  import {
    getFirestore,
    doc,
    getDoc,
    setDoc,
    addDoc,
    collection,
    getDocs,
    query,
    where,
    limit,
    runTransaction,
    serverTimestamp,
    updateDoc
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";
  import {
    getAuth,
    signInAnonymously
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";

  const firebaseConfig = {
    apiKey:"AIzaSyA80bAAGPuyscnTVS-zwrxE9Jp3tPiS1gM",
    authDomain:"events-339ce.firebaseapp.com",
    databaseURL:"https://events-339ce-default-rtdb.europe-west1.firebasedatabase.app",
    projectId:"events-339ce",
    storageBucket:"events-339ce.firebasestorage.app",
    messagingSenderId:"175601544315",
    appId:"1:175601544315:web:00c94b4affa972b3a286de"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const auth = getAuth(app);

  // Try anonymous auth so Firestore rules with request.auth != null will work
  signInAnonymously(auth).catch(err => {
    console.error("Anonymous auth failed:", err);
  });

  const qs = s => document.querySelector(s);

  // LOGIN DOM
  const authWrapper = qs("#pos-auth-wrapper");
  const authAlertEl = qs("#auth-alert");
  const loginForm = qs("#pos-login-form");
  const loginUsernameEl = qs("#pos-login-username");
  const loginPinEl = qs("#pos-login-pin");
  const loginBtn = qs("#pos-login-btn");

  // POS DOM
  const shellEl = qs("#pos-shell");
  const subtitleEl = qs("#subtitle");
  const brandLogoEl = qs("#brand-logo");
  const brandChipTextEl = qs("#brand-chip-text");
  const userInitialsEl = qs("#user-initials");
  const userNameEl = qs("#user-name");
  const userRoleEl = qs("#user-role");
  const branchBadgeEl = qs("#branch-badge");
  const globalAlertEl = qs("#global-alert");

  const leftCardTitleEl = qs("#left-card-title");
  const leftCardSubtitleEl = qs("#left-card-subtitle");
  const codeInputLabelEl = qs("#code-input-label");
  const codeInputHintEl = qs("#code-input-hint");
  const cartCardTitleEl = qs("#cart-card-title");
  const cartCardSubtitleEl = qs("#cart-card-subtitle");
  const summarySubtotalLabelEl = qs("#summary-subtotal-label");
  const summaryTotalLabelEl = qs("#summary-total-label");
  const summaryPaymentLabelEl = qs("#summary-payment-label");
  const summaryTaxLabelEl = qs("#summary-tax-label");
  const summaryServiceLabelEl = qs("#summary-service-label");
  const returnNoteEl = qs("#return-note");

  const codeInputEl = qs("#code-input");
  const btnAddCode = qs("#btn-add-code");

  const cartTbody = qs("#cart-tbody");
  const summarySubtotalEl = qs("#summary-subtotal");
  const summaryTaxEl = qs("#summary-tax");
  const summaryServiceEl = qs("#summary-service");
  const summaryTotalEl = qs("#summary-total");
  const paymentMethodEl = qs("#payment-method");
  const btnClearCart = qs("#btn-clear-cart");

  const productsListEl = qs("#products-list");
  const topSearchEl = qs("#top-product-search");
  const cartSummaryCountEl = qs("#cart-summary-count");
  const cartSummaryTotalEl = qs("#cart-summary-total");
  const btnOpenCheckoutTop = qs("#btn-open-checkout");
  const btnOpenCheckoutSecondary = qs("#btn-open-checkout-secondary");

  const modeSaleBtn = qs("#mode-sale");
  const modeReturnBtn = qs("#mode-return");

  const returnFullRowEl = qs("#return-full-row");
  const btnReturnFull = qs("#btn-return-full");

  // Discount DOM
  const discountCodeInputEl = qs("#discount-code-input");
  const btnApplyDiscount = qs("#btn-apply-discount");
  const discountRowEl = qs("#discount-row");
  const summaryDiscountEl = qs("#summary-discount");
  const discountLabelEl = qs("#discount-label");

  // Offline DOM
  const offlineStatusEl = qs("#offline-status");
  const offlineQueueListEl = qs("#offline-queue-list");

  // Checkout modal DOM
  const checkoutModalEl = qs("#checkout-modal");
  const checkoutAlertEl = qs("#checkout-alert");
  const checkoutTotalEl = qs("#checkout-total");
  const checkoutPaymentSummaryEl = qs("#checkout-payment-summary");
  const checkoutNameEl = qs("#checkout-customer-name");
  const checkoutPhoneEl = qs("#checkout-customer-phone");
  const checkoutEmailEl = qs("#checkout-customer-email");
  const checkoutCardTxnRowEl = qs("#card-txn-row");
  const checkoutCardTxnEl = qs("#checkout-card-txn");
  const checkoutSuggestionsEl = qs("#checkout-customer-suggestions");
  const checkoutTitleEl = qs("#checkout-title");
  const checkoutSubtitleEl = qs("#checkout-subtitle");
  const checkoutOriginalOrderNoteEl = qs("#checkout-original-order-note");
  const btnCheckoutCancel = qs("#btn-checkout-cancel");
  const btnCheckoutConfirm = qs("#btn-checkout-confirm");
  const checkoutModal = qs("#checkout-modal");

  // Product modal DOM
  const productModalEl = qs("#product-modal");
  const productModalTitleEl = qs("#product-modal-title");
  const productModalSubtitleEl = qs("#product-modal-subtitle");
  const productModalPriceEl = qs("#product-modal-price");
  const productModalImageEl = qs("#product-modal-image");
  const productModalNameEl = qs("#product-modal-name");
  const productModalCodeEl = qs("#product-modal-code");
  const productModalStockEl = qs("#product-modal-stock");
  const productModalVariantsRowEl = qs("#product-modal-variants-row");
  const productModalVariantsEl = qs("#product-modal-variants");
  const productModalQtyEl = qs("#product-modal-qty");
  const btnProductModalCancel = qs("#btn-product-modal-cancel");
  const btnProductModalAdd = qs("#btn-product-modal-add");

  let brandId = null;
  let branchId = null;
  let brandData = null;
  let branchData = null;
  let posUser = null;

  let products = [];
  let cartItems = [];
  let currentCustomerId = null;
  let lastCustomerSearchTerm = "";
  let currentMode = "sale"; // "sale" | "return"
  let currentReturnOrderMeta = null; // {orderDocId, orderId, data}
 


  let taxPercent = 0;
  let servicePercent = 0;

  // Discount state
  let appliedDiscount = null; // { id, code, percent, scope }
  let currentCustomerHasUsedDiscountBefore = false;

  // Offline orders queue
  let offlineOrders = [];
  const OFFLINE_KEY_PREFIX = "luma_pos_offline_orders";
  const CRED_KEY = "luma_pos_credentials";

  let currentProductForModal = null;
  let currentFlatVariants = [];

  const WEBHOOK_URL = "https://farid-seven.app.n8n.cloud/webhook-test/a25f6f37-cbb0-4bb8-9d3a-161bcef4ab9c";

  function getOfflineKeyForBrandBranch(){
    return `${OFFLINE_KEY_PREFIX}_${brandId || "noBrand"}_${branchId || "noBranch"}`;
  }

  function showAuthAlert(msg){
    authAlertEl.innerHTML = `<div class="auth-alert auth-alert-error">${msg}</div>`;
  }
  function clearAuthAlert(){
    authAlertEl.innerHTML = "";
  }
  function showGlobalAlert(msg,type="info"){
    let cls = "alert-info";
    if(type==="error") cls = "alert-error";
    if(type==="ok") cls = "alert-ok";
    globalAlertEl.innerHTML = `<div class="alert ${cls}">${msg}</div>`;
    setTimeout(()=>{ globalAlertEl.innerHTML = ""; }, 4000);
  }

  function initialsFromNameOrUsername(name,username){
    if(name){
      const p = name.trim().split(" ");
      if(p.length === 1) return p[0].slice(0,2).toUpperCase();
      return (p[0][0]+p[p.length-1][0]).toUpperCase();
    }
    if(username){
      const s = username.toString();
      if(s.length<=2) return s.toUpperCase();
      const parts = s.split(/[._-]/).filter(Boolean);
      if(parts.length===0) return s.slice(0,2).toUpperCase();
      return (parts[0][0]+(parts[1]?.[0] || "")).toUpperCase();
    }
    return "U";
  }

function computeTotals(){
  let subtotal = 0;
  cartItems.forEach(item=>{
    subtotal += item.price * item.qty;
  });

  let discountAmount = 0;
  let effectiveSubtotal = subtotal;

  if(appliedDiscount && appliedDiscount.percent > 0 && subtotal > 0){
    discountAmount = subtotal * (appliedDiscount.percent / 100);
    if(discountAmount > subtotal) discountAmount = subtotal;
    effectiveSubtotal = subtotal - discountAmount;
  }

  // üëâ Use original order's tax/service for RETURNS
  let effectiveTaxPercent = taxPercent;
  let effectiveServicePercent = servicePercent;

  if(currentMode === "return" && currentReturnOrderMeta && currentReturnOrderMeta.data){
    const od = currentReturnOrderMeta.data;
    if (typeof od.taxPercent === "number") {
      effectiveTaxPercent = od.taxPercent;
    }
    if (typeof od.servicePercent === "number") {
      effectiveServicePercent = od.servicePercent;
    }
  }

  const taxAmount = effectiveSubtotal * (effectiveTaxPercent/100);
  const serviceAmount = effectiveSubtotal * (effectiveServicePercent/100);
  const total = effectiveSubtotal + taxAmount + serviceAmount;

  return { subtotal, discountAmount, taxAmount, serviceAmount, total };
}

  function updateCartSummary(totals){
    const totalItems = cartItems.reduce((sum,i)=>sum + i.qty,0);
    cartSummaryCountEl.textContent = totalItems === 1 ? "1 item" : `${totalItems} items`;
    cartSummaryTotalEl.textContent = totals.total.toFixed(2);
  }

  function renderCart(){
    if(cartItems.length === 0){
      cartTbody.innerHTML = `<tr><td colspan="6" class="empty">No items yet. ${
        currentMode==="sale"
          ? "Scan or select a product."
          : "Load an order in return mode."
      }</td></tr>`;
      summarySubtotalEl.textContent = "0.00";
      summaryTaxEl.textContent = "0.00";
      summaryServiceEl.textContent = "0.00";
      summaryTotalEl.textContent = "0.00";

      // reset discount
      appliedDiscount = null;
      discountRowEl.style.display = "none";
      summaryDiscountEl.textContent = "-0.00";
      if(discountCodeInputEl) discountCodeInputEl.value = "";

      updateCartSummary({subtotal:0,taxAmount:0,serviceAmount:0,total:0});
      return;
    }
    let html = "";
    cartItems.forEach((item,idx)=>{
      const line = item.price * item.qty;
      const qtyInfo = (currentMode==="return" && item.originalQty != null)
        ? ` (${item.qty}/${item.originalQty})`
        : "";
      html += `
        <tr>
          <td>${item.name}</td>
          <td>${item.code || ""}</td>
          <td>
            <div class="qty-control">
              <button class="qty-btn" data-idx="${idx}" data-action="dec">-</button>
              <span class="qty-val">${item.qty}${qtyInfo}</span>
              <button class="qty-btn" data-idx="${idx}" data-action="inc">+</button>
            </div>
          </td>
          <td>${item.price.toFixed(2)}</td>
          <td>${line.toFixed(2)}</td>
          <td><button class="btn btn-small btn-danger" data-idx="${idx}" data-action="remove">‚úï</button></td>
        </tr>`;
    });
    cartTbody.innerHTML = html;

    const totals = computeTotals();

    
    // Discount row (also in return mode if original order had a discount)
if(appliedDiscount && totals.discountAmount > 0){
  discountRowEl.style.display = "flex";
  summaryDiscountEl.textContent = `-${totals.discountAmount.toFixed(2)}`;

  const labelPrefix = currentMode === "sale" ? "Discount" : "Original discount";
  const label = appliedDiscount.code
    ? `${labelPrefix} (${appliedDiscount.code} ¬∑ ${appliedDiscount.percent}%)`
    : `${labelPrefix} (${appliedDiscount.percent}%)`;

  discountLabelEl.textContent = label;
} else {
  discountRowEl.style.display = "none";
  summaryDiscountEl.textContent = "-0.00";
}


    summarySubtotalEl.textContent = totals.subtotal.toFixed(2);
    summaryTaxEl.textContent = totals.taxAmount.toFixed(2);
    summaryServiceEl.textContent = totals.serviceAmount.toFixed(2);
    summaryTotalEl.textContent = totals.total.toFixed(2);
    updateCartSummary(totals);

    cartTbody.querySelectorAll(".qty-btn").forEach(btn=>{
      btn.addEventListener("click",()=>{
        const idx = parseInt(btn.dataset.idx,10);
        const action = btn.dataset.action;
        if(Number.isNaN(idx)) return;
        if(action==="inc"){
          if(currentMode==="return"){
            const maxQty = cartItems[idx].originalQty ?? cartItems[idx].qty;
            cartItems[idx].qty = Math.min(cartItems[idx].qty + 1, maxQty);
          }else{
            cartItems[idx].qty += 1;
          }
        }else if(action==="dec"){
          cartItems[idx].qty = Math.max(1, cartItems[idx].qty - 1);
        }
        renderCart();
      });
    });
    cartTbody.querySelectorAll(".btn-danger").forEach(btn=>{
      btn.addEventListener("click",()=>{
        const idx = parseInt(btn.dataset.idx,10);
        if(Number.isNaN(idx)) return;
        cartItems.splice(idx,1);
        renderCart();
      });
    });
  }

  function addProductToCart(prod, qty=1){
    if(!prod) return;
    const idForCart = prod.id;
    const existingIdx = cartItems.findIndex(i=>i.id===idForCart);
    if(existingIdx>=0){
      if(currentMode==="return"){
        const maxQty = cartItems[existingIdx].originalQty ?? cartItems[existingIdx].qty;
        cartItems[existingIdx].qty = Math.min(cartItems[existingIdx].qty + qty, maxQty);
      }else{
        cartItems[existingIdx].qty += qty;
      }
    }else{
      cartItems.push({
        id:prod.id,
        baseId: prod.baseId || prod.id,
        name:prod.name || "Item",
        code:prod.code || "",
        price:typeof prod.price==="number" ? prod.price : 0,
        qty,
        originalQty: currentMode==="return" ? (prod.originalQty ?? qty) : null,
        variantKey: prod.variantKey || null,
        variantChoices: Array.isArray(prod.variantChoices) ? prod.variantChoices : null,
        variantMeta: prod.variantMeta || null,
        imageUrl: prod.imageUrl || null,
        productUrl: prod.productUrl || prod.url || null
      });
    }
    renderCart();
  }

  function getBaseStockForProduct(product){
    // If we have variants, sum their stock fields
    if (Array.isArray(product.variants) && product.variants.length){
      let sum = 0;
      product.variants.forEach(v => {
        if (!v) return;
        const q =
          typeof v.stockQty === "number" ? v.stockQty :
          (typeof v.quantity === "number" ? v.quantity :
          (typeof v.qty === "number" ? v.qty :
          (typeof v.stock === "number" ? v.stock : 0)));
        sum += q;
      });
      return sum;
    }

    // Fallback: use product-level fields
    if (typeof product.stockQty === "number") return product.stockQty;
    if (typeof product.stock === "number")    return product.stock;
    if (typeof product.quantity === "number") return product.quantity;
    if (typeof product.qty === "number")      return product.qty;
    return null;
  }

  function computeProductStockLeft(product){
    const baseStock = getBaseStockForProduct(product);
    if (typeof baseStock !== "number") return null;

    const baseId = product.id;
    const usedInCart = cartItems.reduce((sum, item) => {
      const pid = item.baseId || item.id;
      return pid === baseId ? sum + item.qty : sum;
    }, 0);

    const left = baseStock - usedInCart;
    return left < 0 ? 0 : left;
  }

  function buildFlatVariantsForProduct(product){
    const flat = [];
    const variants = product.variants;
    if(!Array.isArray(variants)) return flat;

    variants.forEach((v,vIndex)=>{
      // Prefer the product-level variantGroup if group name is missing
      let groupName = v.name || v.groupName || product.variantGroup || "";

      const labelsArr = Array.isArray(v.labels)
        ? v.labels
        : (Array.isArray(v.options) ? v.options : null);

      if(labelsArr){
        labelsArr.forEach((lbl,lIndex)=>{
          const labelName = typeof lbl === "string"
            ? lbl
            : (lbl.label || lbl.name || `Option ${lIndex+1}`);

          const qty =
            typeof lbl.stockQty === "number" ? lbl.stockQty :
            (typeof lbl.quantity === "number" ? lbl.quantity :
            (typeof lbl.qty === "number" ? lbl.qty :
            (typeof lbl.stock === "number" ? lbl.stock : null)));

          flat.push({
            groupName,
            labelName,
            qty,
            groupIndex:vIndex,
            labelIndex:lIndex
          });
        });
      }else{
        const labelName = v.label || v.name || `Variant ${vIndex+1}`;
        const qty =
          typeof v.stockQty === "number" ? v.stockQty :
          (typeof v.quantity === "number" ? v.quantity :
          (typeof v.qty === "number" ? v.qty :
          (typeof v.stock === "number" ? v.stock : null)));

        flat.push({
          groupName,
          labelName,
          qty,
          groupIndex:vIndex,
          labelIndex:null
        });
      }
    });

    return flat;
  }

  async function loadBrandAndBranch(){
    const brandRef = doc(db,"brands",brandId);
    const brandSnap = await getDoc(brandRef);
    if(!brandSnap.exists()) throw new Error("Brand not found");
    brandData = brandSnap.data();
    const brandName = brandData.name || "Brand";
    const country = brandData.country || "";

    if(brandData.logoUrl || brandData.logo){
      const logoSrc = brandData.logoUrl || brandData.logo;
      brandLogoEl.innerHTML = `<img src="${logoSrc}" alt="${brandName} logo"/>`;
    }else{
      brandLogoEl.textContent = brandName[0]?.toUpperCase() || "B";
    }

    brandChipTextEl.textContent = country ? `${brandName} ‚Ä¢ ${country}` : brandName;
    subtitleEl.textContent = "POS for this branch. Sales and returns are stored in the system.";

    const branchRef = doc(brandRef,"branches",branchId);
    const branchSnap = await getDoc(branchRef);
    if(!branchSnap.exists()) throw new Error("Branch not found");
    branchData = branchSnap.data();
    branchBadgeEl.textContent = `Branch: ${branchData.name || "Branch"}`;

    // VAT / Tax
    const branchVat = typeof branchData.vat === "number" ? branchData.vat : null;
    const brandVat = typeof brandData.vat === "number" ? brandData.vat : null;

    const branchTax = typeof branchData.taxPercent === "number"
      ? branchData.taxPercent
      : (typeof branchData.tax === "number" ? branchData.tax
      : (typeof branchData.vatPercent === "number" ? branchData.vatPercent : null));
    const brandTax = typeof brandData.taxPercent === "number"
      ? brandData.taxPercent
      : (typeof brandData.tax === "number" ? brandData.tax
      : (typeof brandData.vatPercent === "number" ? brandData.vatPercent : null));

    taxPercent =
      branchVat != null ? branchVat :
      brandVat != null ? brandVat :
      branchTax != null ? branchTax :
      brandTax != null ? brandTax : 0;

    // Service Fee
    const branchServiceFee = typeof branchData.serviceFee === "number" ? branchData.serviceFee : null;
    const brandServiceFee = typeof brandData.serviceFee === "number" ? brandData.serviceFee : null;

    const branchService = typeof branchData.servicePercent === "number"
      ? branchData.servicePercent
      : (typeof branchData.service === "number" ? branchData.service
      : (typeof branchData.serviceFeePercent === "number" ? branchData.serviceFeePercent : null));
    const brandService = typeof brandData.servicePercent === "number"
      ? brandData.servicePercent
      : (typeof brandData.service === "number" ? brandData.service
      : (typeof brandData.serviceFeePercent === "number" ? brandData.serviceFeePercent : null));

    servicePercent =
      branchServiceFee != null ? branchServiceFee :
      brandServiceFee != null ? brandServiceFee :
      branchService != null ? branchService :
      brandService != null ? brandService : 0;

    summaryTaxLabelEl.textContent = `VAT (${taxPercent || 0}%)`;
    summaryServiceLabelEl.textContent = `Service Fee (${servicePercent || 0}%)`;
  }

  async function loadProducts(){
    productsListEl.innerHTML = `<div class="empty">Loading products‚Ä¶</div>`;
    // products in brands/{brandId}/products (shared with dashboard)
    const productsCol = collection(db,"brands",brandId,"products");
    const snap = await getDocs(productsCol);
    products = [];
    snap.forEach(d=>{
      const p = d.data() || {};
      if(p.isActive === false) return;
      const rawStock =
        typeof p.stockQty === "number" ? p.stockQty :
        (typeof p.stock === "number" ? p.stock :
        (typeof p.quantity === "number" ? p.quantity :
        (typeof p.qty === "number" ? p.qty :
        (typeof p.currentStock === "number" ? p.currentStock : null))));

      products.push({
        id:d.id,
        name:p.name || "Item",
        code:p.code || "",
        price:typeof p.price==="number" ? p.price : 0,
        variants:Array.isArray(p.variants)? p.variants : null,
        stock: rawStock,
        imageUrl: p.imageUrl || p.photoUrl || p.image || null,
        productUrl: p.productUrl || p.url || null
      });
    });
    renderProductsList();
  }

  function renderProductsList(filterText=""){
    const ft = filterText.trim().toLowerCase();
    const list = ft
      ? products.filter(p=>{
          const s = `${p.name} ${p.code}`.toLowerCase();
          return s.includes(ft);
        })
      : products;

    if(list.length===0){
      productsListEl.innerHTML = `<div class="empty">No products found for this branch.</div>`;
      return;
    }
    productsListEl.innerHTML = "";
    list.forEach(p=>{
      const div = document.createElement("div");
      div.className = "product-item" + (currentMode==="return" ? " disabled" : "");
      const variantsInfo = p.variants && p.variants.length
        ? ` ‚Ä¢ Variants: ${p.variants.map(v=>v.name || "").filter(Boolean).join(", ")}`
        : "";

      const stockDisplay = computeProductStockLeft(p);
      const stockInfo = typeof stockDisplay === "number"
        ? ` ‚Ä¢ Stock: ${stockDisplay} left`
        : "";

      const thumbInner = p.imageUrl
        ? `<img src="${p.imageUrl}" alt="${p.name}"/>`
        : (p.name ? p.name[0].toUpperCase() : "P");

      div.innerHTML = `
        <div class="product-main">
          <div class="product-thumb">${thumbInner}</div>
          <div>
            <div class="product-title">${p.name}</div>
            <div class="product-meta">Code: ${p.code || "‚Äî"}${variantsInfo}${stockInfo}</div>
          </div>
        </div>
        <div class="product-right">
          <div><strong>${p.price.toFixed(2)}</strong></div>
          <button class="btn btn-small btn-primary product-add-btn" data-id="${p.id}" ${currentMode==="return" ? "disabled" : ""}>Add</button>
        </div>`;

      const btn = div.querySelector(".product-add-btn");
      btn.addEventListener("click",(e)=>{
        e.stopPropagation();
        if(currentMode==="return") return;
        openProductModal(p);
      });

      div.addEventListener("click",()=>{
        if(currentMode==="return") return;
        openProductModal(p);
      });

      productsListEl.appendChild(div);
    });
  }

  function findProductInMemoryByCode(code){
    return products.find(p=>p.code === code) || null;
  }

  async function handleAddByCodeSale(){
    const code = codeInputEl.value.trim();
    if(!code){
      showGlobalAlert("Enter or scan a code first.","error");
      return;
    }
    let prod = findProductInMemoryByCode(code);
    if(!prod){
      // Same fixed products path as dashboard
      const productsCol = collection(db,"brands",brandId,"products");
      const qCode = query(productsCol, where("code","==",code), limit(1));
      const snap = await getDocs(qCode);
      if(!snap.empty){
        const d = snap.docs[0];
        const p = d.data() || {};
        const rawStock =
          typeof p.stock === "number" ? p.stock :
          (typeof p.quantity === "number" ? p.quantity :
          (typeof p.qty === "number" ? p.qty :
          (typeof p.currentStock === "number" ? p.currentStock : null)));
        prod = {
          id:d.id,
          name:p.name || "Item",
          code:p.code || "",
          price:typeof p.price==="number" ? p.price : 0,
          variants:Array.isArray(p.variants)? p.variants : null,
          stock: rawStock,
          imageUrl: p.imageUrl || p.photoUrl || p.image || null,
          productUrl: p.productUrl || p.url || null
        };
        products.push(prod);
      }
    }
    if(!prod){
      showGlobalAlert(`No product found with code "${code}".`,"error");
      return;
    }
    // If product has variants, open modal; otherwise quick add
    if(prod.variants && prod.variants.length){
      openProductModal(prod);
    }else{
      addProductToCart(prod,1);
    }
    codeInputEl.value = "";
    codeInputEl.focus();
  }

  async function handleLoadOrderForReturn(){
    const input = codeInputEl.value.trim();
    if(!input){
      showGlobalAlert("Enter or scan an order ID or customer phone first.","error");
      return;
    }
    const ordersCol = collection(db,"brands",brandId,"branches",branchId,"orders");

    // 1) Try by orderId
    let foundOrderDoc = null;
    try{
      const qOrderId = query(ordersCol, where("orderId","==",input), limit(1));
      const snapId = await getDocs(qOrderId);
      if(!snapId.empty){
        foundOrderDoc = snapId.docs[0];
      }
    }catch(e){
      console.warn("OrderId search error",e);
    }

    // 2) If not found, try by customer phone (use latest)
    if(!foundOrderDoc){
      try{
        const qPhone = query(ordersCol, where("customerPhone","==",input), limit(5));
        const snapPhone = await getDocs(qPhone);
        if(!snapPhone.empty){
          let docs = snapPhone.docs.slice();
          docs.sort((a,b)=>{
            const da = (a.data().createdAtLocal || "");
            const db = (b.data().createdAtLocal || "");
            return db.localeCompare(da);
          });
          foundOrderDoc = docs[0];
          if(snapPhone.size > 1){
            showGlobalAlert(`Found multiple orders for this phone. Using the most recent one (${foundOrderDoc.data().orderId || "no ID"}).`,"info");
          }
        }
      }catch(e){
        console.warn("Phone search error",e);
      }
    }

    if(!foundOrderDoc){
      showGlobalAlert(`No order found with ID or phone "${input}".`,"error");
      return;
    }

    const data = foundOrderDoc.data() || {};
    const originalOrderId = data.orderId || input;

    // Build map of already returned quantities per product
    const returnedMap = {};
    try{
      const qReturns = query(ordersCol, where("originalOrderId","==", originalOrderId));
      const returnsSnap = await getDocs(qReturns);
      returnsSnap.forEach(docR=>{
        const dR = docR.data() || {};
        if(!dR.isReturn) return;
        const itemsR = Array.isArray(dR.items) ? dR.items : [];
        itemsR.forEach(itR=>{
          const pid = itR.productId || itR.id || "";
          if(!pid) return;
          const q = typeof itR.qty === "number" ? Math.abs(itR.qty) : 0;
          if(q <= 0) return;
          returnedMap[pid] = (returnedMap[pid] || 0) + q;
        });
      });
    }catch(e){
      console.warn("Error reading previous returns",e);
    }

    // Also include offline queued returns that haven't synced yet
    offlineOrders
      .filter(o => o.mode === "return" && o.originalOrderMeta && o.originalOrderMeta.orderId === originalOrderId)
      .forEach(o=>{
        (o.cartItems || []).forEach(i=>{
          const pid = i.baseId || i.id;
          if(!pid) return;
          const q = typeof i.qty === "number" ? i.qty : 0;
          if(q <= 0) return;
          returnedMap[pid] = (returnedMap[pid] || 0) + q;
        });
      });

    currentReturnOrderMeta = {
      orderDocId:foundOrderDoc.id,
      orderId:originalOrderId,
      data
    };
// üí° Update VAT / Service labels in the UI for this order
if (typeof data.taxPercent === "number") {
  summaryTaxLabelEl.textContent = `VAT (${data.taxPercent}%)`;
}
if (typeof data.servicePercent === "number") {
  summaryServiceLabelEl.textContent = `Service Fee (${data.servicePercent}%)`;
}
    const items = Array.isArray(data.items) ? data.items : [];
    cartItems = [];
    let anyRemaining = false;

    items.forEach(it=>{
      const pid = it.productId || it.id || "";
      if(!pid) return;
      const originalQty = typeof it.qty === "number" ? Math.abs(it.qty) : 1;
      const alreadyReturned = returnedMap[pid] || 0;
      const remaining = originalQty - alreadyReturned;
      if(remaining <= 0) return; // fully refunded
      anyRemaining = true;
      cartItems.push({
        id:pid,
        baseId:pid,
        name:it.name || "Item",
        code:it.code || "",
        price:typeof it.price==="number" ? it.price : 0,
        qty:remaining,
        originalQty,
        variantKey: it.variantKey || null,
        variantChoices: Array.isArray(it.variantChoices) ? it.variantChoices : null,
        imageUrl: it.productImageUrl || it.imageUrl || null,
        productUrl: it.productUrl || it.url || null,
        variantMeta: null // will be reconstructed when adjusting stock using variantKey
      });
    });

  if(!anyRemaining){
  cartItems = [];
  renderCart();
  showGlobalAlert("This order is already fully refunded. No remaining quantity to return.","info");
  codeInputEl.value = "";
  codeInputEl.focus();
  return;
}

// üîπ NEW: reuse original discount on this order
if (typeof data.discountPercent === "number" && data.discountPercent > 0) {
  appliedDiscount = {
    id: data.discountId || null,
    code: (data.discountCode || "").toString().toUpperCase() || null,
    percent: data.discountPercent,
    scope: data.discountScope || "store_and_online"
  };
} else {
  appliedDiscount = null;
}

renderCart();
showGlobalAlert(`Loaded order ${originalOrderId} for return.`,`ok`);
codeInputEl.value = "";
codeInputEl.focus();
  }

  async function findExistingCustomer(email,phone){
    const customersCol = collection(db,"brands",brandId,"customers");
    if(email){
      const qEmail = query(customersCol, where("email","==",email), limit(1));
      const snap = await getDocs(qEmail);
      if(!snap.empty){
        const d = snap.docs[0];
        return { id:d.id, data:d.data() };
      }
    }
    if(phone){
      const qPhone = query(customersCol, where("phone","==",phone), limit(1));
      const snap = await getDocs(qPhone);
      if(!snap.empty){
        const d = snap.docs[0];
        return { id:d.id, data:d.data() };
      }
    }
    return null;
  }

  async function searchCustomersForSuggestions(term){
    const t = term.trim();
    if(t.length < 1){
      checkoutSuggestionsEl.classList.add("hidden");
      checkoutSuggestionsEl.innerHTML = "";
      lastCustomerSearchTerm = "";
      return;
    }
    lastCustomerSearchTerm = t;

    const customersCol = collection(db,"brands",brandId,"customers");
    const candidates = [];

    try{
      const qPhone = query(
        customersCol,
        where("phone", ">=", t),
        where("phone", "<=", t + "\uf8ff"),
        limit(5)
      );
      const snapPhone = await getDocs(qPhone);
      snapPhone.forEach(d=>{
        candidates.push({ id:d.id, data:d.data() });
      });
    }catch(e){ console.warn("Phone prefix search error",e); }

    try{
      const qEmail = query(
        customersCol,
        where("email", ">=", t),
        where("email", "<=", t + "\uf8ff"),
        limit(5)
      );
      const snapEmail = await getDocs(qEmail);
      snapEmail.forEach(d=>{
        if(!candidates.find(c=>c.id===d.id)){
          candidates.push({ id:d.id, data:d.data() });
        }
      });
    }catch(e){ console.warn("Email prefix search error",e); }

    try{
      const qName = query(
        customersCol,
        where("name", ">=", t),
        where("name", "<=", t + "\uf8ff"),
        limit(5)
      );
      const snapName = await getDocs(qName);
      snapName.forEach(d=>{
        if(!candidates.find(c=>c.id===d.id)){
          candidates.push({ id:d.id, data:d.data() });
        }
      });
    }catch(e){ console.warn("Name prefix search error",e); }

    if(lastCustomerSearchTerm !== t) return;

    if(candidates.length === 0){
      checkoutSuggestionsEl.classList.add("hidden");
      checkoutSuggestionsEl.innerHTML = "";
      return;
    }

    checkoutSuggestionsEl.innerHTML = "";
    candidates.forEach(c=>{
      const data = c.data || {};
      const name = data.name || "(No name)";
      const phone = data.phone || "";
      const email = data.email || "";
      const div = document.createElement("div");
      div.className = "customer-suggestion-item";
      div.innerHTML = `
        <div><strong>${name}</strong></div>
        <div class="text-muted">${phone || "No phone"} ‚Ä¢ ${email || "No email"}</div>
      `;
      div.addEventListener("click",()=>{
        currentCustomerId = c.id;
        currentCustomerHasUsedDiscountBefore = !!data.hasUsedDiscountCode;
        checkoutNameEl.value = name || "";
        checkoutPhoneEl.value = phone || "";
        checkoutEmailEl.value = email || "";
        checkoutSuggestionsEl.classList.add("hidden");
        checkoutSuggestionsEl.innerHTML = "";
      });
      checkoutSuggestionsEl.appendChild(div);
    });
    checkoutSuggestionsEl.classList.remove("hidden");
  }

  async function ensureCustomer(){
  const name = checkoutNameEl.value.trim();
  const phone = checkoutPhoneEl.value.trim();
  const email = checkoutEmailEl.value.trim();
  const customersCol = collection(db,"brands",brandId,"customers");

  if(!name && !phone && !email){
    currentCustomerHasUsedDiscountBefore = false;
    return { id:null, data:null };
  }

  // If we already have a customerId in memory, update + read the flag
  if(currentCustomerId){
    const ref = doc(customersCol,currentCustomerId);
    await setDoc(ref,{
      name: name || null,
      phone: phone || null,
      email: email || null,
      updatedAt:serverTimestamp()
    },{ merge:true });

    // read the discount flag
    try{
      const snap = await getDoc(ref);
      if(snap.exists()){
        const d = snap.data() || {};
        currentCustomerHasUsedDiscountBefore = !!d.hasUsedDiscountCode;
      }else{
        currentCustomerHasUsedDiscountBefore = false;
      }
    }catch(e){
      console.warn("Failed to read hasUsedDiscountCode", e);
      currentCustomerHasUsedDiscountBefore = false;
    }

    return { id:currentCustomerId, data:{ name, phone, email } };
  }

  // Try find existing by email/phone
  const found = await findExistingCustomer(email,phone);
  if(found){
    const ref = doc(customersCol,found.id);
    await setDoc(ref,{
      name: name || found.data.name || null,
      phone: phone || found.data.phone || null,
      email: email || found.data.email || null,
      updatedAt:serverTimestamp()
    },{ merge:true });

    currentCustomerId = found.id;
    currentCustomerHasUsedDiscountBefore = !!found.data.hasUsedDiscountCode;

    const data = {
      name: name || found.data.name || null,
      phone: phone || found.data.phone || null,
      email: email || found.data.email || null
    };
    return { id:found.id, data };
  }

  // Brand-new customer ‚Üí definitely never used a discount
  const newRef = await addDoc(customersCol,{
    name: name || null,
    phone: phone || null,
    email: email || null,
    hasUsedDiscountCode:false,
    createdAt:serverTimestamp(),
    updatedAt:serverTimestamp()
  });
  currentCustomerId = newRef.id;
  currentCustomerHasUsedDiscountBefore = false;

  return { id:newRef.id, data:{ name, phone, email } };
}


  async function generateOrderId(){
    const now = new Date();
    const dd = String(now.getDate()).padStart(2,"0");
    const mm = String(now.getMonth()+1).padStart(2,"0");
    const humanDate = `${dd}${mm}`;
    const dateKey = `${now.getFullYear()}-${mm}-${dd}`;
    const countersRef = doc(db,"brands",brandId,"branches",branchId,"orderCounters",dateKey);

    const orderNumber = await runTransaction(db, async (tx)=>{
      const snap = await tx.get(countersRef);
      let current = 0;
      if(snap.exists()){
        current = snap.data().value || 0;
      }
      const next = current + 1;
      tx.set(countersRef,{ value:next },{ merge:true });
      return next;
    });

    return `${humanDate}-${orderNumber}`;
  }

  function makeLocalOrderIdForOffline(){
    const now = new Date();
    const dd = String(now.getDate()).padStart(2,"0");
    const mm = String(now.getMonth()+1).padStart(2,"0");
    const hh = String(now.getHours()).padStart(2,"0");
    const mi = String(now.getMinutes()).padStart(2,"0");
    const ss = String(now.getSeconds()).padStart(2,"0");
    return `${dd}${mm}-L${hh}${mi}${ss}`;
  }

  function showCheckoutAlert(msg){
    checkoutAlertEl.textContent = msg;
    checkoutAlertEl.classList.remove("hidden");
    checkoutAlertEl.classList.add("modal-alert","modal-alert-error");
  }
  function clearCheckoutAlert(){
    checkoutAlertEl.textContent = "";
    checkoutAlertEl.classList.add("hidden");
  }

  function nameOrNull(v){
    const t = v.trim();
    return t ? t : null;
  }
  function phoneOrNull(v){
    const t = v.trim();
    return t ? t : null;
  }
  function emailOrNull(v){
    const t = v.trim();
    return t ? t : null;
  }

  function openCheckoutModal(){
    if(cartItems.length === 0){
      showGlobalAlert("Cart is empty.","error");
      return;
    }
    clearCheckoutAlert();
    const totals = computeTotals();
    const total = totals.total;
    checkoutTotalEl.textContent = total.toFixed(2);
    const pm = paymentMethodEl.value;
    const pmLabelMap = {
      cash:"Cash",
      card:"Card",
      wallet:"Wallet",
      other:"Other"
    };
    checkoutPaymentSummaryEl.textContent = pmLabelMap[pm] || pm;
    checkoutCardTxnRowEl.style.display = pm === "card" ? "block" : "none";

    currentCustomerId = null;
    currentCustomerHasUsedDiscountBefore = false;
    checkoutNameEl.value = "";
    checkoutPhoneEl.value = "";
    checkoutEmailEl.value = "";
    checkoutCardTxnEl.value = "";
    checkoutSuggestionsEl.classList.add("hidden");
    checkoutSuggestionsEl.innerHTML = "";

    if(currentMode==="return" && currentReturnOrderMeta && currentReturnOrderMeta.data){
      const od = currentReturnOrderMeta.data;
      const cn = od.customerName || "";
      const cp = od.customerPhone || "";
      const ce = od.customerEmail || "";
      checkoutNameEl.value = cn;
      checkoutPhoneEl.value = cp;
      checkoutEmailEl.value = ce;
      checkoutOriginalOrderNoteEl.style.display = "block";
      checkoutOriginalOrderNoteEl.textContent = `Return for order ${od.orderId || currentReturnOrderMeta.orderId || ""}. Original total: ${
        typeof od.total==="number" ? Math.abs(od.total).toFixed(2) : ""
      }`;
      checkoutTitleEl.textContent = "Return ‚Äî customer & refund details";
      checkoutSubtitleEl.textContent = "Confirm customer and refund info. This will create a return linked to the original order.";
    }else{
      checkoutOriginalOrderNoteEl.style.display = "none";
      checkoutTitleEl.textContent = "Checkout ‚Äî customer & payment";
      checkoutSubtitleEl.textContent = "Name and email are required. Suggestions appear as you type.";
    }

    checkoutModalEl.style.display = "flex";
    checkoutNameEl.focus();
  }

  function closeCheckoutModal(){
    checkoutModalEl.style.display = "none";
  }

  function openProductModal(product){
    currentProductForModal = product;
    currentFlatVariants = buildFlatVariantsForProduct(product);

    productModalTitleEl.textContent = "Add item";
    productModalSubtitleEl.textContent = currentFlatVariants.length
      ? "Choose one variant (e.g. size or color) and quantity."
      : "Confirm quantity and add to cart.";
    productModalNameEl.textContent = product.name || "Item";
    productModalCodeEl.textContent = product.code ? `Code: ${product.code}` : "";
    productModalPriceEl.textContent = (typeof product.price === "number" ? product.price : 0).toFixed(2);

    if(product.imageUrl){
      productModalImageEl.innerHTML = `<img src="${product.imageUrl}" alt="${product.name}"/>`;
    }else{
      productModalImageEl.textContent = product.name ? (product.name[0] || "I").toUpperCase() : "No image";
    }

    const left = computeProductStockLeft(product);
    if(left != null){
      productModalStockEl.textContent = `Available in this branch: ${left} unit(s).`;
    }else{
      productModalStockEl.textContent = "Stock not set for this item.";
    }

    productModalVariantsEl.innerHTML = "";
    if(currentFlatVariants.length){
      productModalVariantsRowEl.style.display = "flex";
      const groupDiv = document.createElement("div");
      groupDiv.className = "field-pos";
      const labelDiv = document.createElement("div");
      labelDiv.className = "field-label-pos";
      labelDiv.textContent = "Variant";
      const selectEl = document.createElement("select");
      selectEl.className = "field-select-pos";
      selectEl.id = "product-variant-select";

      currentFlatVariants.forEach((fv, idx)=>{
        const optionEl = document.createElement("option");
        optionEl.value = String(idx);

        const baseLabel = fv.groupName
          ? `${fv.groupName} ‚Äî ${fv.labelName}`
          : fv.labelName;

        // compute how many of this variant are left after cart items
        let rawQty = typeof fv.qty === "number" ? fv.qty : null;
        let availableQty = rawQty;

        if(rawQty != null){
          const usedInCartVariant = cartItems.reduce((sum,item)=>{
            if((item.baseId || item.id) !== product.id) return sum;
            if(!item.variantChoices || !item.variantChoices.length) return sum;

            const vc = item.variantChoices[0];
            const sameLabel = vc.choice === fv.labelName;
            const sameGroup =
              !fv.groupName || !vc.group
                ? true
                : (vc.group === fv.groupName);

            return (sameLabel && sameGroup) ? sum + item.qty : sum;
          },0);

          availableQty = Math.max(0, rawQty - usedInCartVariant);
        }

        const qtySuffix = availableQty != null ? ` (${availableQty} left)` : "";
        optionEl.textContent = baseLabel + qtySuffix;
        selectEl.appendChild(optionEl);
      });

      groupDiv.appendChild(labelDiv);
      groupDiv.appendChild(selectEl);
      productModalVariantsEl.appendChild(groupDiv);
    }else{
      productModalVariantsRowEl.style.display = "none";
    }
    productModalQtyEl.value = "1";
    productModalEl.style.display = "flex";
    productModalQtyEl.focus();
  }

  function closeProductModal(){
    productModalEl.style.display = "none";
    currentProductForModal = null;
    currentFlatVariants = [];
  }

  function loadOfflineOrders(){
    try{
      const key = getOfflineKeyForBrandBranch();
      const raw = localStorage.getItem(key);
      if(!raw){
        offlineOrders = [];
      }else{
        const parsed = JSON.parse(raw);
        offlineOrders = Array.isArray(parsed) ? parsed : [];
      }
    }catch(e){
      console.warn("Failed to load offline orders",e);
      offlineOrders = [];
    }
    renderOfflineOrders();
  }

  function saveOfflineOrders(){
    try{
      const key = getOfflineKeyForBrandBranch();
      localStorage.setItem(key, JSON.stringify(offlineOrders));
    }catch(e){
      console.warn("Failed to save offline orders",e);
    }
    renderOfflineOrders();
  }

  function renderOfflineOrders(){
    if(!offlineOrders.length){
      offlineStatusEl.style.display = "none";
      offlineQueueListEl.textContent = "";
      return;
    }
    const isOffline = !navigator.onLine;
    const msg = `${isOffline ? "Offline" : "Online"} ‚Äî queued orders: ${offlineOrders.length}. <button id="btn-sync-offline" class="btn btn-small btn-ghost" style="margin-left:8px;">Sync now</button>`;
    offlineStatusEl.style.display = "block";
    offlineStatusEl.innerHTML = msg;

    offlineQueueListEl.textContent = offlineOrders
      .map(o=>`${o.mode==="return"?"Return":"Sale"} ${o.orderId} ‚Ä¢ ${o.totalPositive.toFixed(2)}`)
      .join(" | ");

    const btnSync = document.querySelector("#btn-sync-offline");
    if(btnSync){
      btnSync.onclick = ()=>{ syncQueuedOrders(); };
    }
  }

  function queueOfflineOrder({mode,totalPositive,subtotalPositive,taxPercentValue,servicePercentValue,taxAmountValue,serviceAmountValue,paymentMethod,cardTxn,name,phone,email,cartItemsSnapshot,originalOrderMeta}){
    const orderId = makeLocalOrderIdForOffline();
    const localId = Date.now() + "-" + Math.random().toString(36).slice(2,8);
    const offlineOrder = {
      localId,
      mode,
      orderId,
      totalPositive,
      subtotalPositive,
      taxPercent: taxPercentValue,
      servicePercent: servicePercentValue,
      taxAmount: taxAmountValue,
      serviceAmount: serviceAmountValue,
      paymentMethod,
      cardTxn,
      name,
      phone,
      email,
      cartItems: cartItemsSnapshot.map(i=>({
        id:i.id,
        baseId:i.baseId || i.id,
        name:i.name,
        code:i.code || "",
        price:i.price,
        qty:i.qty,
        originalQty:i.originalQty ?? null,
        variantKey:i.variantKey || null,
        variantChoices:Array.isArray(i.variantChoices) ? i.variantChoices : null,
        variantMeta:i.variantMeta || null,
        productImageUrl:i.imageUrl || null,
        productUrl:i.productUrl || null
      })),
      brandId,
      branchId,
      brandName: brandData?.name || null,
      branchName: branchData?.name || null,
      brandLogoUrl: brandData?.logoUrl || brandData?.logo || null,
      posUser:{
  id: posUser?.id || null,
  username: posUser?.username || null,
  displayName: posUser?.displayName || null,
  role: posUser?.role || null
},
      originalOrderMeta: originalOrderMeta || null,
      createdAtLocal:(new Date()).toISOString()
    };
    offlineOrders.push(offlineOrder);
    saveOfflineOrders();
    showGlobalAlert(`Offline ‚Äî ${mode==="return"?"return":"order"} queued as ${orderId}. It will sync when internet is back.`,"info");

    cartItems = [];
    renderCart();
    currentReturnOrderMeta = null;
    closeCheckoutModal();
    codeInputEl.focus();
  }

  function resolveVariantMetaFromKey(item, brandIdParam){
    if(!item.variantKey || item.variantMeta || !item.baseId) return item.variantMeta;
    if(brandIdParam !== brandId) return item.variantMeta; // only resolve for current in-memory brand

    const pid = item.baseId;
    const prod = products.find(p=>p.id === pid);
    if(!prod || !Array.isArray(prod.variants)) return item.variantMeta;

    const [groupNameKey, choiceNameKey] = item.variantKey.split(":");
    if(!groupNameKey || !choiceNameKey) return item.variantMeta;

    const gNameTarget = groupNameKey.trim().toLowerCase();
    const cNameTarget = choiceNameKey.trim().toLowerCase();

    for(let gi=0; gi<prod.variants.length; gi++){
      const vg = prod.variants[gi] || {};
      const vgName = (vg.name || vg.groupName || "").toString().trim().toLowerCase();
      if(vgName !== gNameTarget) continue;

      const labelsArr = Array.isArray(vg.labels) ? vg.labels
                        : (Array.isArray(vg.options) ? vg.options : null);
      if(labelsArr){
        for(let li=0; li<labelsArr.length; li++){
          const lbl = labelsArr[li];
          const lblName = (typeof lbl === "string"
            ? lbl
            : (lbl.label || lbl.name || "")).toString().trim().toLowerCase();
          if(lblName === cNameTarget){
            return { groupIndex: gi, labelIndex: li };
          }
        }
      }else{
        const lblName = (vg.label || vg.name || "").toString().trim().toLowerCase();
        if(lblName === cNameTarget){
          return { groupIndex: gi, labelIndex: null };
        }
      }
    }
    return item.variantMeta;
  }

  async function adjustStockForOrder(cartItemsSource, mode, brandIdParam = brandId){
    const sign = mode === "return" ? 1 : -1; // sale reduces, return adds

    // Group items by product
    const byProduct = new Map();
    cartItemsSource.forEach(item=>{
      const pid = item.baseId || item.id;
      if(!pid) return;
      if(!byProduct.has(pid)) byProduct.set(pid, []);
      byProduct.get(pid).push(item);
    });

    for(const [pid, items] of byProduct.entries()){
      const productRef = doc(db,"brands",brandIdParam,"products",pid);

      try{
        await runTransaction(db, async (tx)=>{
          const snap = await tx.get(productRef);
          if(!snap.exists()) return;

          const data = snap.data() || {};
          let variantsArr = Array.isArray(data.variants) ? [...data.variants] : null;

          // Start baseStock from variants sum if we have per-variant stock
          let baseStock;
          if(variantsArr){
            baseStock = variantsArr.reduce((sum,v)=>{
              const vs =
                typeof v.stockQty === "number" ? v.stockQty :
                (typeof v.quantity === "number" ? v.quantity :
                (typeof v.qty === "number" ? v.qty :
                (typeof v.stock === "number" ? v.stock : 0)));
              return sum + vs;
            },0);
          }else{
            baseStock =
              typeof data.stockQty === "number" ? data.stockQty :
              (typeof data.stock === "number" ? data.stock :
              (typeof data.quantity === "number" ? data.quantity :
              (typeof data.qty === "number" ? data.qty : 0)));
          }

          const readQty = (obj) =>
            typeof obj.stockQty === "number" ? obj.stockQty :
            typeof obj.quantity === "number" ? obj.quantity :
            typeof obj.qty === "number" ? obj.qty :
            typeof obj.stock === "number" ? obj.stock : 0;

          const writeQty = (obj, newVal) => ({
            ...obj,
            stockQty: newVal,
            quantity: newVal,
            qty: newVal,
            stock: newVal
          });

          // Apply each cart item
          items.forEach(item => {
            const delta = sign * item.qty;
            baseStock = Math.max(0, baseStock + delta);

            if (!variantsArr) return;

            // Prefer using variantMeta
            if (item.variantMeta && typeof item.variantMeta.groupIndex === "number") {
              const gi = item.variantMeta.groupIndex;
              const li = item.variantMeta.labelIndex;

              if (!variantsArr[gi]) return;

              const v = { ...variantsArr[gi] };

              if (li != null) {
                let labelsArr = Array.isArray(v.labels) ? [...v.labels]
                  : (Array.isArray(v.options) ? [...v.options] : null);

                if (!labelsArr || !labelsArr[li]) {
                  variantsArr[gi] = v;
                  return;
                }

                const lbl = labelsArr[li];
                const currentVarStock = readQty(lbl);
                const newVarStock = Math.max(0, currentVarStock + delta);

                labelsArr[li] = writeQty(lbl, newVarStock);

                if (Array.isArray(v.labels)) v.labels = labelsArr;
                else v.options = labelsArr;

                variantsArr[gi] = v;
              } else {
                const currentVarStock = readQty(v);
                const newVarStock = Math.max(0, currentVarStock + delta);
                variantsArr[gi] = writeQty(v, newVarStock);
              }

              return;
            }

            // Fallback: match using variantChoices
            if (item.variantChoices && item.variantChoices.length) {
              const choice = item.variantChoices[0].choice;
              const group  = item.variantChoices[0].group || null;

              variantsArr = variantsArr.map(v => {
                if (!v) return v;

                const labelsArr = Array.isArray(v.labels) ? v.labels
                  : (Array.isArray(v.options) ? v.options : null);

                if (labelsArr) {
                  const newLabels = labelsArr.map(lbl => {
                    const lblName = (typeof lbl === "string"
                      ? lbl
                      : (lbl.label || lbl.name || ""));

                    const sameLabel = lblName === choice;
                    const sameGroup = !group || !v.name
                      ? true
                      : (v.name === group);

                    if (!sameLabel || !sameGroup) return lbl;

                    const currentVarStock = readQty(lbl);
                    const newVarStock = Math.max(0, currentVarStock + delta);
                    return writeQty(lbl, newVarStock);
                  });

                  if (Array.isArray(v.labels)) return { ...v, labels: newLabels };
                  return { ...v, options: newLabels };
                } else {
                  const sameLabel = v.label === choice || v.name === choice;
                  const sameGroup = !group || !v.groupName
                    ? true
                    : (v.groupName === group);

                  if (!sameLabel || !sameGroup) return v;

                  const currentVarStock = readQty(v);
                  const newVarStock = Math.max(0, currentVarStock + delta);
                  return writeQty(v, newVarStock);
                }
              });
            }
          });

          const updateData = {
            stockQty: baseStock,
            stock: baseStock,
            quantity: baseStock,
            qty: baseStock
          };
          if(variantsArr) updateData.variants = variantsArr;

          tx.set(productRef, updateData, { merge:true });
        });

        // Update local cache for this product (top-level stock only)
        if(brandIdParam === brandId){
          const idx = products.findIndex(p=>p.id === pid);
          if(idx >= 0){
            const p = products[idx];
            const currentTop =
              typeof p.stockQty === "number" ? p.stockQty :
              (typeof p.stock === "number" ? p.stock :
              (typeof p.quantity === "number" ? p.quantity :
              (typeof p.qty === "number" ? p.qty : 0)));

            const totalDelta = items.reduce((sum,i)=> sum + sign * i.qty, 0);
            const newTop = Math.max(0, currentTop + totalDelta);
            products[idx] = { ...p, stockQty:newTop, stock:newTop, quantity:newTop, qty:newTop };
          }
        }
      }catch(e){
        console.warn("Failed to adjust stock for product", pid, e);
      }
    }

    // Re-render list with updated product stock
    renderProductsList(topSearchEl.value);
  }

  async function syncQueuedOrders(){
    if(!offlineOrders.length){
      showGlobalAlert("No queued orders to sync.","info");
      return;
    }
    if(!navigator.onLine){
      showGlobalAlert("Still offline. Cannot sync queued orders.","error");
      return;
    }
    const syncedIds = [];
    for(const o of offlineOrders){
      try{
        const ordersCol = collection(db,"brands",o.brandId,"branches",o.branchId,"orders");
        const orderRef = doc(ordersCol);

        const itemsForDb = o.cartItems.map(i=>{
          const qtySign = (o.mode==="return" ? -1 : 1);
          const qtyVal = i.qty * qtySign;
          const lineTotalVal = i.price * i.qty * qtySign;
          return {
            productId:i.baseId || i.id,
            name:i.name,
            code:i.code || null,
            qty:qtyVal,
            price:i.price,
            lineTotal:lineTotalVal,
            variantKey:i.variantKey || null,
            variantChoices:i.variantChoices || null,
            productImageUrl:i.productImageUrl || i.imageUrl || null,
            productUrl:i.productUrl || null
          };
        });

        const sign = o.mode==="return" ? -1 : 1;
        const orderData = {
  orderId: o.orderId,
  createdAt: serverTimestamp(),
  createdAtLocal: o.createdAtLocal || (new Date()).toISOString(),
  paymentMethod: o.paymentMethod,
  subtotal: sign * (o.subtotalPositive || o.totalPositive),
  taxPercent: o.taxPercent ?? 0,
  servicePercent: o.servicePercent ?? 0,
  taxAmount: sign * (o.taxAmount ?? 0),
  serviceAmount: sign * (o.serviceAmount ?? 0),
  total: sign * o.totalPositive,
  items: itemsForDb,
  customerId: null,
  customerName: o.name || null,
  customerPhone: o.phone || null,
  customerEmail: o.email || null,
  cardTransaction: o.paymentMethod === "card" ? (o.cardTxn || null) : null,
  brandId: o.brandId,
  branchId: o.branchId,
  status: o.mode === "return" ? "return" : "normal",
  type: o.mode === "return" ? "return" : "sale",
  isReturn: o.mode === "return",
  originalOrderId: o.originalOrderMeta?.orderId || null,
  originalOrderDocId: o.originalOrderMeta?.orderDocId || null,
  originalPaymentMethod: o.originalOrderMeta?.data?.paymentMethod || null,
  cashierId: o.posUser?.id || null,
  cashierUsername: o.posUser?.username || null,
  cashierDisplayName: o.posUser?.displayName || null,
  cashierRole: o.posUser?.role || null
};


        await setDoc(orderRef,orderData);

        try{
          await adjustStockForOrder(o.cartItems, o.mode, o.brandId);
        }catch(e){
          console.warn("Stock adjust (sync) failed",e);
        }

        const payload = {
          orderId:o.orderId,
          orderDocId:orderRef.id,
          createdAt:orderData.createdAtLocal,
          brandId:o.brandId,
          brandName:o.brandName || null,
          brandLogoUrl:o.brandLogoUrl || null,
          branchId:o.branchId,
          branchName:o.branchName || null,
          posUser:o.posUser,
          customer:{
            id:null,
            name:orderData.customerName,
            phone:orderData.customerPhone,
            email:orderData.customerEmail
          },
          total:orderData.total,
          subtotal:orderData.subtotal,
          taxPercent:orderData.taxPercent,
          servicePercent:orderData.servicePercent,
          taxAmount:orderData.taxAmount,
          serviceAmount:orderData.serviceAmount,
          items:itemsForDb,
          paymentMethod:o.paymentMethod,
          cardTransaction:orderData.cardTransaction,
          isReturn:o.mode==="return",
          originalOrderId:orderData.originalOrderId || null
        };

        fetch(WEBHOOK_URL,{
          method:"POST",
          headers:{ "Content-Type":"application/json" },
          body:JSON.stringify(payload)
        }).catch(err=>console.error("Webhook error (sync)",err));

        syncedIds.push(o.localId);
      }catch(err){
        console.error("Failed to sync offline order",o.orderId,err);
      }
    }
    if(syncedIds.length){
      offlineOrders = offlineOrders.filter(o=>!syncedIds.includes(o.localId));
      saveOfflineOrders();
      showGlobalAlert(`Synced ${syncedIds.length} queued order(s) successfully.`,"ok");
    }else{
      showGlobalAlert("Could not sync queued orders. Check console.","error");
    }
  }

  async function recomputeOriginalRefundStatus(originalOrderId, originalOrderDocId){
    if(!originalOrderId || !originalOrderDocId) return;
    try{
      const ordersCol = collection(db,"brands",brandId,"branches",branchId,"orders");
      const qAllReturns = query(ordersCol, where("originalOrderId","==", originalOrderId));
      const snap = await getDocs(qAllReturns);
      let refundedTotal = 0;
      snap.forEach(d=>{
        const data = d.data() || {};
        if(!data.isReturn) return;
        const t = typeof data.total === "number" ? data.total : 0;
        refundedTotal += Math.abs(t);
      });

      const originalTotal = Math.abs(currentReturnOrderMeta?.data?.total || 0);
      let refundStatus = "none";
      const eps = 0.01;
      if(refundedTotal > eps && refundedTotal < originalTotal - eps){
        refundStatus = "partial";
      }else if(refundedTotal >= originalTotal - eps){
        refundStatus = "full";
      }

      const origRef = doc(db,"brands",brandId,"branches",branchId,"orders", originalOrderDocId);
      await updateDoc(origRef,{
        refundStatus,
        refundedTotal
      });
    }catch(e){
      console.warn("Failed to recompute refund status",e);
    }
  }

  async function handleApplyDiscount(){
    if(currentMode !== "sale"){
      showGlobalAlert("Discount codes can only be applied in Sale mode.","error");
      return;
    }

    const rawCode = (discountCodeInputEl?.value || "").trim().toUpperCase();

    // Clear if empty
    if(!rawCode){
      if(appliedDiscount){
        appliedDiscount = null;
        discountRowEl.style.display = "none";
        summaryDiscountEl.textContent = "-0.00";
        showGlobalAlert("Discount removed.","info");
        renderCart();
      }else{
        showGlobalAlert("Enter a discount code first.","error");
      }
      return;
    }

    if(cartItems.length === 0){
      showGlobalAlert("Add items to the cart before applying a discount.","error");
      return;
    }

    try{
      const discountsCol = collection(db,"brands",brandId,"discounts");
      const qDisc = query(discountsCol, where("code","==", rawCode), limit(1));
      const snap = await getDocs(qDisc);

      if(snap.empty){
        showGlobalAlert(`No discount code "${rawCode}" found.`,"error");
        return;
      }

      const d = snap.docs[0];
      const data = d.data() || {};
      const isActive = data.isActive !== false;
      const percent = typeof data.percent === "number" ? data.percent : null;
      const scope = data.scope || "store_and_online";

      if(!isActive){
        showGlobalAlert("This discount code is inactive.","error");
        return;
      }
      if(!percent || percent <= 0){
        showGlobalAlert("This discount code has no valid percentage.","error");
        return;
      }

      if(scope === "online_only"){
        showGlobalAlert("This discount code can only be used online, not at the POS.","error");
        return;
      }

      appliedDiscount = {
        id: d.id,
        code: rawCode,
        percent,
        scope
      };

      showGlobalAlert(`Discount "${rawCode}" applied (${percent}%).`,"ok");
      renderCart();
    }catch(e){
      console.error("Error applying discount code", e);
      showGlobalAlert("Error applying discount code. Check console.","error");
    }
  }

  async function handlePlaceOrder(){
  if(cartItems.length === 0){
    showCheckoutAlert("Cart is empty.");
    return;
  }
  const name = checkoutNameEl.value.trim();
  const email = checkoutEmailEl.value.trim();
  const phone = checkoutPhoneEl.value.trim();
  const pm = paymentMethodEl.value;
  const cardTxn = checkoutCardTxnEl.value.trim();

  if(!name){
    showCheckoutAlert("Customer name is required.");
    return;
  }
  if(!email){
    showCheckoutAlert("Customer email is required.");
    return;
  }
  if(pm === "card" && !cardTxn){
    showCheckoutAlert("Card transaction number is required for card payments.");
    return;
  }

  const totals = computeTotals();
  const totalPositive = totals.total;
  const subtotalPositive = totals.subtotal;
  const taxAmount = totals.taxAmount;
  const serviceAmount = totals.serviceAmount;
  const discountAmount = totals.discountAmount || 0;
  const paymentMethod = pm;

  btnCheckoutConfirm.disabled = true;
  btnCheckoutConfirm.textContent = "Placing‚Ä¶";
  try{
    const customerResult = await ensureCustomer();
    const customerId = customerResult.id;
    const customer = customerResult.data;

    // Use GLOBAL appliedDiscount (from discount logic)
const orderHasDiscount = !!appliedDiscount;
const isReturnMode = currentMode === "return";

// üëâ New rule:
// - Not a return
// - No discount was applied on THIS order
const willIssueNewCoupon =
  !isReturnMode &&
  !orderHasDiscount;


    // If we are issuing a new coupon, mark the customer in Firestore
    if(customerId && willIssueNewCoupon && navigator.onLine){
      try{
        const customersCol = collection(db,"brands",brandId,"customers");
        const customerRef = doc(customersCol, customerId);
        await setDoc(customerRef, { hasUsedDiscountCode:true }, { merge:true });
        currentCustomerHasUsedDiscountBefore = true;
      }catch(e){
        console.warn("Failed to flag hasUsedDiscountCode on customer", e);
      }
    }

    const orderId = await generateOrderId();
    const now = new Date();

    const itemsForDb = cartItems.map(i=>{
      const qtySign = (currentMode==="return" ? -1 : 1);
      const qtyVal = i.qty * qtySign;
      const lineTotalVal = i.price * i.qty * qtySign;
      return {
        productId:i.baseId || i.id,
        name:i.name,
        code:i.code || null,
        qty:qtyVal,
        price:i.price,
        lineTotal:lineTotalVal,
        variantKey:i.variantKey || null,
        variantChoices:i.variantChoices || null,
        productImageUrl:i.imageUrl || null,
        productUrl:i.productUrl || null
      };
    });

    const ordersCol = collection(db,"brands",brandId,"branches",branchId,"orders");
    const orderRef = doc(ordersCol);

    const sign = currentMode==="return" ? -1 : 1;

const baseOrderData = {
  orderId,
  createdAt: serverTimestamp(),
  createdAtLocal: now.toISOString(),
  paymentMethod,
  subtotal: sign * subtotalPositive,
  taxPercent,
  servicePercent,
  taxAmount: sign * taxAmount,
  serviceAmount: sign * serviceAmount,
  total: sign * totalPositive,
  discountPercent: appliedDiscount?.percent || 0,
  discountAmount: sign * (discountAmount || 0),
  discountCode: appliedDiscount?.code || null,
  discountScope: appliedDiscount?.scope || null,
  items: itemsForDb,
  customerId: customerId || null,
  customerName: customer?.name || nameOrNull(checkoutNameEl.value),
  customerPhone: customer?.phone || phoneOrNull(checkoutPhoneEl.value),
  customerEmail: customer?.email || emailOrNull(checkoutEmailEl.value),
  cardTransaction: paymentMethod === "card" ? cardTxn : null,
  brandId,
  branchId,

  // üëá ADD THESE 4 LINES
  cashierId: posUser?.id || null,
  cashierUsername: posUser?.username || null,
  cashierDisplayName: posUser?.displayName || null,
  cashierRole: posUser?.role || null,
};


    const orderData = currentMode==="return"
      ? {
          ...baseOrderData,
          status:"return",
          type:"return",
          isReturn:true,
          originalOrderId: currentReturnOrderMeta?.orderId || null,
          originalOrderDocId: currentReturnOrderMeta?.orderDocId || null,
          originalPaymentMethod: currentReturnOrderMeta?.data?.paymentMethod || null
        }
      : {
          ...baseOrderData,
          status:"normal",
          type:"sale",
          isReturn:false
        };

    await setDoc(orderRef,orderData);

    // Update stock
    try{
      await adjustStockForOrder(cartItems, currentMode, brandId);
    }catch(e){
      console.warn("Stock adjust failed",e);
    }

    // For returns, recompute original refund status
    if(currentMode==="return" && currentReturnOrderMeta?.orderDocId && navigator.onLine){
      await recomputeOriginalRefundStatus(
        currentReturnOrderMeta.orderId,
        currentReturnOrderMeta.orderDocId
      );
    }

    // Build webhook payload
    const payload = {
      orderId,
      orderDocId:orderRef.id,
      createdAt:now.toISOString(),
      brandId,
      brandName:brandData?.name || null,
      brandLogoUrl:brandData?.logoUrl || brandData?.logo || null,
      branchId,
      branchName:branchData?.name || null,
      posUser:{
        username:posUser?.username || null,
        displayName:posUser?.displayName || null,
        role:posUser?.role || null
      },
      customer:{
        id:customerId || null,
        name:orderData.customerName,
        phone:orderData.customerPhone,
        email:orderData.customerEmail
      },
      total:orderData.total,
      subtotal:orderData.subtotal,
      taxPercent:orderData.taxPercent,
      servicePercent:orderData.servicePercent,
      taxAmount:orderData.taxAmount,
      serviceAmount:orderData.serviceAmount,
      items:itemsForDb,
      paymentMethod,
      cardTransaction: paymentMethod === "card" ? cardTxn : null,
      isReturn: currentMode==="return",
      originalOrderId: orderData.originalOrderId || null,

     discount: appliedDiscount ? {
    code: appliedDiscount.code,
    percent: appliedDiscount.percent,
    scope: appliedDiscount.scope || "store_and_online",
    amount: discountAmount
  } : null,

  // üëâ what n8n/email should use for issuing a coupon
  shouldIssueNewCoupon: willIssueNewCoupon,
  refundAmount: currentMode === "return" ? totalPositive : 0
};
    console.log("POS ‚Üí Webhook payload:", payload);

    fetch(WEBHOOK_URL,{
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body:JSON.stringify(payload)
    }).catch(err=>console.error("Webhook error",err));

    showGlobalAlert(`${currentMode==="return" ? "Return" : "Order"} ${orderId} created successfully.`,"ok");

    // Reset discount for next order
    appliedDiscount = null;
    if(discountCodeInputEl) discountCodeInputEl.value = "";
    discountRowEl.style.display = "none";
    summaryDiscountEl.textContent = "-0.00";

    cartItems = [];
    renderCart();
    currentCustomerId = null;
    currentReturnOrderMeta = null;
    closeCheckoutModal();
    codeInputEl.focus();
  }catch(err){
    console.error(err);
    const networkCodes = ["unavailable","failed-precondition","network-request-failed"];
    if(!navigator.onLine || networkCodes.includes(err.code)){
      const snapshot = cartItems.map(i=>({...i}));
      queueOfflineOrder({
        mode:currentMode,
        totalPositive,
        subtotalPositive,
        taxPercentValue:taxPercent,
        servicePercentValue:servicePercent,
        taxAmountValue:taxAmount,
        serviceAmountValue:serviceAmount,
        paymentMethod,
        cardTxn,
        name,
        phone,
        email,
        cartItemsSnapshot:snapshot,
        originalOrderMeta:currentReturnOrderMeta
      });
    }else{
      showCheckoutAlert("Error placing order. Check console.");
    }
  }finally{
    btnCheckoutConfirm.disabled = false;
    btnCheckoutConfirm.textContent = "Confirm & place order";
  }
}


  function updateModeUI(){
    // reset discount on mode change
    appliedDiscount = null;
    if(discountCodeInputEl) discountCodeInputEl.value = "";
    discountRowEl.style.display = "none";
    summaryDiscountEl.textContent = "-0.00";

    if(currentMode==="sale"){
      modeSaleBtn.classList.add("mode-pill-active");
      modeReturnBtn.classList.remove("mode-pill-active");
      leftCardTitleEl.textContent = "Products";
      leftCardSubtitleEl.textContent = "Scan barcode, type a code, or tap ‚ÄúAdd‚Äù to send items to cart.";
      codeInputLabelEl.textContent = "Scan or type product code";
      codeInputHintEl.textContent = "Works with barcode scanners that behave like a keyboard and send Enter after scanning.";
      cartCardTitleEl.textContent = "Cart";
      cartCardSubtitleEl.textContent = "Adjust quantities or remove items. Proceed to add customer & payment details.";
      summarySubtotalLabelEl.textContent = "Subtotal";
      summaryTotalLabelEl.textContent = "Total";
      summaryPaymentLabelEl.textContent = "Payment method";
      returnNoteEl.style.display = "none";
      subtitleEl.textContent = "POS ‚Äî Sale mode. Every sale is stored in the system.";
      productsListEl.style.display = "block";
      topSearchEl.disabled = false;
      topSearchEl.placeholder = "Search products (name/code)";
      btnOpenCheckoutTop.textContent = "Proceed";
      btnOpenCheckoutSecondary.textContent = "Proceed";
      returnFullRowEl.style.display = "none";
    }else{
      modeSaleBtn.classList.remove("mode-pill-active");
      modeReturnBtn.classList.add("mode-pill-active");
      leftCardTitleEl.textContent = "Returns";
      leftCardSubtitleEl.textContent = "Enter or scan the original order ID or customer phone, then choose full or partial refund.";
      codeInputLabelEl.textContent = "Order ID or customer phone";
      codeInputHintEl.textContent = "Use the printed order ID (e.g. 1507-3) or the customer's phone.";
      cartCardTitleEl.textContent = "Return cart";
      cartCardSubtitleEl.textContent = "Set the quantity to return for each item, then refund.";
      summarySubtotalLabelEl.textContent = "Refund subtotal";
      summaryTotalLabelEl.textContent = "Refund total";
      summaryPaymentLabelEl.textContent = "Refund method";
      returnNoteEl.style.display = "block";
      subtitleEl.textContent = "POS ‚Äî Return mode. Refunds are stored as negative totals linked to the original order.";
      productsListEl.style.display = "none";
      topSearchEl.disabled = true;
      topSearchEl.placeholder = "Products hidden in return mode";
      btnOpenCheckoutTop.textContent = "Refund selected items";
      btnOpenCheckoutSecondary.textContent = "Refund selected items";
      returnFullRowEl.style.display = "flex";
    }
    renderProductsList(topSearchEl.value);
    cartItems = [];
    currentReturnOrderMeta = null;
    renderCart();
    codeInputEl.value = "";
    codeInputEl.focus();
  }

  function prefillLoginFromStorage(){
    try{
      const raw = localStorage.getItem(CRED_KEY);
      if(!raw) return;
      const obj = JSON.parse(raw);
      if(obj && typeof obj === "object"){
        if(obj.username) loginUsernameEl.value = obj.username;
        if(obj.pin) loginPinEl.value = obj.pin;
      }
    }catch(e){
      console.warn("Failed to prefill login from storage",e);
    }
  }

  async function handleLogin(evt){
    evt.preventDefault();
    clearAuthAlert();
    const username = loginUsernameEl.value.trim();
    const pin = loginPinEl.value.trim();
    if(!username || !pin){
      showAuthAlert("Enter username and PIN.");
      return;
    }
    try{
      loginBtn.disabled = true;
      loginBtn.textContent = "Logging in‚Ä¶";

      const posUsersCol = collection(db,"posUsers");
      const qUser = query(
        posUsersCol,
        where("username","==",username),
        where("pin","==",pin),
        limit(1)
      );
      const snap = await getDocs(qUser);
      if(snap.empty){
        showAuthAlert("No POS user found with this username/PIN combination.");
        loginBtn.disabled = false;
        loginBtn.textContent = "Log in";
        return;
      }
      const d = snap.docs[0];
      const u = d.data() || {};
      if(u.isActive === false){
        showAuthAlert("This POS user is disabled.");
        loginBtn.disabled = false;
        loginBtn.textContent = "Log in";
        return;
      }
      if(!u.brandId || !u.branchId){
        showAuthAlert("POS user is missing brand or branch assignment (brandId/branchId).");
        loginBtn.disabled = false;
        loginBtn.textContent = "Log in";
        return;
      }

      try{
        localStorage.setItem(CRED_KEY, JSON.stringify({username, pin}));
      }catch(e){
        console.warn("Failed to store credentials",e);
      }

      posUser = {
        id:d.id,
        username:u.username,
        displayName:u.displayName || u.username,
        role:u.role || "cashier"
      };
      brandId = u.brandId;
      branchId = u.branchId;

      authWrapper.style.display = "none";
      shellEl.style.display = "flex";
      document.body.style.alignItems = "flex-start";

      userNameEl.textContent = posUser.displayName;
      userRoleEl.textContent = posUser.role;
      userInitialsEl.textContent = initialsFromNameOrUsername(posUser.displayName,posUser.username);

      await loadBrandAndBranch();
      await loadProducts();
      loadOfflineOrders();

      codeInputEl.focus();
    }catch(err){
      console.error("POS login error:", err);
      let msg = "Login error.";
      if(err.code === "permission-denied"){
        msg = "Firestore rules are blocking access to posUsers. Allow read on posUsers for authenticated POS clients (anonymous auth is used).";
      }
      showAuthAlert(msg + (err.code ? ` (${err.code})` : ""));
    }finally{
      loginBtn.disabled = false;
      loginBtn.textContent = "Log in";
    }
  }

  function initEvents(){
    loginForm.addEventListener("submit",handleLogin);

    btnAddCode.addEventListener("click",()=>{
      if(currentMode==="sale"){
        handleAddByCodeSale();
      }else{
        handleLoadOrderForReturn();
      }
    });
    codeInputEl.addEventListener("keydown",(e)=>{
      if(e.key==="Enter"){
        e.preventDefault();
        if(currentMode==="sale"){
          handleAddByCodeSale();
        }else{
          handleLoadOrderForReturn();
        }
      }
    });

    btnClearCart.addEventListener("click",()=>{
      cartItems = [];
      currentReturnOrderMeta = null;
      renderCart();
      codeInputEl.focus();
    });

    topSearchEl.addEventListener("input",()=>{
      renderProductsList(topSearchEl.value);
    });

    const openCheckout = ()=>openCheckoutModal();
    btnOpenCheckoutTop.addEventListener("click",openCheckout);
    btnOpenCheckoutSecondary.addEventListener("click",openCheckout);

    btnCheckoutCancel.addEventListener("click",()=>{
      closeCheckoutModal();
      codeInputEl.focus();
    });

    btnCheckoutConfirm.addEventListener("click",handlePlaceOrder);

    checkoutNameEl.addEventListener("input",()=>searchCustomersForSuggestions(checkoutNameEl.value));
    checkoutPhoneEl.addEventListener("input",()=>searchCustomersForSuggestions(checkoutPhoneEl.value));
    checkoutEmailEl.addEventListener("input",()=>searchCustomersForSuggestions(checkoutEmailEl.value));

    checkoutModal.addEventListener("click",(e)=>{
      if(e.target === checkoutModal){
        closeCheckoutModal();
        codeInputEl.focus();
      }
    });

    modeSaleBtn.addEventListener("click",()=>{
      if(currentMode!=="sale"){
        currentMode = "sale";
        updateModeUI();
      }
    });
    modeReturnBtn.addEventListener("click",()=>{
      if(currentMode!=="return"){
        currentMode = "return";
        updateModeUI();
      }
    });

    btnReturnFull.addEventListener("click",()=>{
      if(currentMode!=="return"){
        showGlobalAlert("Full refund is only available in return mode.","error");
        return;
      }
      if(!currentReturnOrderMeta){
        showGlobalAlert("Load an order first before returning full order.","error");
        return;
      }
      if(cartItems.length===0){
        showGlobalAlert("No items loaded from this order.","error");
        return;
      }
      cartItems.forEach(i=>{
        if(i.originalQty != null){
          i.qty = i.originalQty;
        }
      });
      renderCart();
      openCheckoutModal();
    });

    // Product modal events
    btnProductModalCancel.addEventListener("click",()=>{
      closeProductModal();
    });
    productModalEl.addEventListener("click",(e)=>{
      if(e.target === productModalEl){
        closeProductModal();
      }
    });
    btnProductModalAdd.addEventListener("click",()=>{
      if(!currentProductForModal) return;
      const product = currentProductForModal;
      let qty = parseInt(productModalQtyEl.value,10);
      if(!qty || qty < 1) qty = 1;

      const variantSelectEl = productModalVariantsEl.querySelector("#product-variant-select");
      let selectedVariant = null;
      if(variantSelectEl && currentFlatVariants && currentFlatVariants.length){
        const idx = parseInt(variantSelectEl.value,10);
        if(!Number.isNaN(idx) && currentFlatVariants[idx]){
          selectedVariant = currentFlatVariants[idx];
        }
      }

      const variantsInfo = [];
      let variantKey = null;
      let displayName = product.name;
      let availableQtyForVariant = null;

      if(selectedVariant){
        const groupName = selectedVariant.groupName || "Variant";
        const choiceName = selectedVariant.labelName;
        variantsInfo.push({ group:groupName, choice:choiceName });
        variantKey = `${groupName}:${choiceName}`;
        displayName = `${product.name} (${groupName}: ${choiceName})`;
        if(typeof selectedVariant.qty === "number"){
          const usedInCartVariant = cartItems.reduce((sum,i)=>{
            if((i.baseId || i.id) === product.id && i.variantKey === variantKey){
              return sum + i.qty;
            }
            return sum;
          },0);
          availableQtyForVariant = selectedVariant.qty - usedInCartVariant;
        }
      }

      if(availableQtyForVariant != null && qty > availableQtyForVariant){
        showGlobalAlert(`Only ${availableQtyForVariant} unit(s) left for this variant in this branch.`,"error");
        return;
      }else{
        const left = computeProductStockLeft(product);
        if(left != null && qty > left){
          showGlobalAlert(`Only ${left} unit(s) left of ${product.name} in this branch.`,"error");
          return;
        }
      }

      addProductToCart({
        ...product,
        baseId: product.id,
        id: variantKey ? `${product.id}::${variantKey}` : product.id,
        name: displayName,
        variantKey,
        variantChoices: variantsInfo,
        variantMeta: selectedVariant ? {
          groupIndex: selectedVariant.groupIndex,
          labelIndex: selectedVariant.labelIndex
        } : null
      }, qty);

      closeProductModal();
    });

    // Discount events
    btnApplyDiscount.addEventListener("click", ()=>{ handleApplyDiscount(); });
    discountCodeInputEl.addEventListener("keydown",(e)=>{
      if(e.key === "Enter"){
        e.preventDefault();
        handleApplyDiscount();
      }
    });

    window.addEventListener("online",()=>{
      renderOfflineOrders();
      showGlobalAlert("Back online. You can sync queued orders from the offline banner.","info");
    });
    window.addEventListener("offline",()=>{
      renderOfflineOrders();
      showGlobalAlert("You are offline. New orders will be queued locally.","error");
    });
  }

  function init(){
    prefillLoginFromStorage();
    initEvents();
    updateModeUI();
  }

  init();
  </script>
</body>
</html>
